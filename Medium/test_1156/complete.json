{
  "metadata": {
    "graph_path": "./logic_graph.png",
    "num_solutions": 7,
    "family_stats": {
      "1": {
        "core": 1,
        "branch": 4
      },
      "2": {
        "core": 1,
        "branch": 1
      }
    }
  },
  "knowledge_base": {
    "rules": [
      {
        "id": "Rule1",
        "formal": "(A10 → (A8 → G))",
        "prover9_expression": "(prepared(chef, food) -> (served(food, customer) -> satisfied(customer)))",
        "natural": "Provided that a chef prepares a food, then if that food is served to a customer, the customer becomes satisfied."
      },
      {
        "id": "Rule2",
        "formal": "(A11 → A9)",
        "prover9_expression": "(fresh(ingredient) -> cooked(chef, food))",
        "natural": "Under the condition that an ingredient is fresh, then a chef cooks a food."
      },
      {
        "id": "Rule3",
        "formal": "(A12 → A10)",
        "prover9_expression": "(stored(ingredient) -> prepared(chef, food))",
        "natural": "Whenever an ingredient is stored, then a chef prepares a food."
      },
      {
        "id": "Rule4",
        "formal": "(A13 → A11)",
        "prover9_expression": "(delivered(supplier, ingredient) -> fresh(ingredient))",
        "natural": "If a supplier delivers an ingredient, then that ingredient is fresh."
      },
      {
        "id": "Rule5",
        "formal": "(A14 → A12)",
        "prover9_expression": "(purchased(manager, ingredient) -> stored(ingredient))",
        "natural": "In the event that a manager purchases an ingredient, then that ingredient is stored."
      },
      {
        "id": "Rule6",
        "formal": "(A15 ∨ (A13 ∨ A14))",
        "prover9_expression": "(expired(ingredient) | (delivered(supplier, ingredient) | purchased(manager, ingredient)))",
        "natural": "Either an ingredient is expired, or a supplier delivers an ingredient, or a manager purchases an ingredient."
      },
      {
        "id": "Rule7",
        "formal": "(A16 ∨ (¬(A4 ∨ A5) → ¬A6))",
        "prover9_expression": "(spoiled(ingredient) | (-(available(table) | reserved(table)) -> -occupied(table)))",
        "natural": "An ingredient is spoiled, or if it is not the case that a table is available or reserved, then the table is not occupied."
      },
      {
        "id": "Rule8",
        "formal": "(A17 → ¬A16)",
        "prover9_expression": "(checked(manager, ingredient) -> -spoiled(ingredient))",
        "natural": "Should a manager check an ingredient, then it is not the case that the ingredient is spoiled."
      },
      {
        "id": "Rule9",
        "formal": "(A18 → A17)",
        "prover9_expression": "(inspected(chef, ingredient) -> checked(manager, ingredient))",
        "natural": "Provided that a chef inspects an ingredient, then a manager checks that ingredient."
      },
      {
        "id": "Rule10",
        "formal": "(A21 → (¬(A19 ∨ A18) → A20))",
        "prover9_expression": "(found(inspector, problem) -> (-(contaminated(ingredient) | inspected(chef, ingredient)) -> discarded(ingredient)))",
        "natural": "If an inspector finds a problem, then whenever it is not the case that an ingredient is contaminated or a chef inspects an ingredient, the ingredient is discarded."
      },
      {
        "id": "Rule11",
        "formal": "(A21 ∨ A22)",
        "prover9_expression": "(found(inspector, problem) | reported(staff, problem))",
        "natural": "An inspector finds a problem or staff reports a problem."
      },
      {
        "id": "Rule12",
        "formal": "(A22 → (¬(A19 ∨ A18) → A20))",
        "prover9_expression": "(reported(staff, problem) -> (-(contaminated(ingredient) | inspected(chef, ingredient)) -> discarded(ingredient)))",
        "natural": "In the event that staff reports a problem, then if it is not the case that an ingredient is contaminated or a chef inspects an ingredient, the ingredient is discarded."
      },
      {
        "id": "Rule13",
        "formal": "(A23 → A24)",
        "prover9_expression": "(clean(table) -> wiped(cleaner, table))",
        "natural": "Should a table be clean, then a cleaner wipes that table."
      },
      {
        "id": "Rule14",
        "formal": "(A24 → A25)",
        "prover9_expression": "(wiped(cleaner, table) -> sanitized(table))",
        "natural": "Whenever a cleaner wipes a table, then the table is sanitized."
      },
      {
        "id": "Rule15",
        "formal": "(A25 → A26)",
        "prover9_expression": "(sanitized(table) -> ready(table))",
        "natural": "Provided that a table is sanitized, then it is ready."
      },
      {
        "id": "Rule16",
        "formal": "(A29 → A28)",
        "prover9_expression": "(arrived(cleaner, work) -> scheduled(cleaner, shift))",
        "natural": "In the event that a cleaner arrives at work, then the cleaner is scheduled for a shift."
      },
      {
        "id": "Rule17",
        "formal": "(A29 ∨ A30)",
        "prover9_expression": "(arrived(cleaner, work) | called(manager, cleaner))",
        "natural": "Either a cleaner arrives at work or a manager calls a cleaner."
      },
      {
        "id": "Rule18",
        "formal": "(A30 → (¬(A26 → (A4 ∨ A5)) → A27))",
        "prover9_expression": "(called(manager, cleaner) -> (-(ready(table) -> (available(table) | reserved(table))) -> dirty(table)))",
        "natural": "Should a manager call a cleaner, then if it is not the case that a ready table implies it is available or reserved, the table is dirty."
      },
      {
        "id": "Rule19",
        "formal": "(A31 → A4)",
        "prover9_expression": "(wood(table) -> available(table))",
        "natural": "Under the condition that a table is wood, then it is available."
      },
      {
        "id": "Rule20",
        "formal": "(A32 → A5)",
        "prover9_expression": "(metal(table) -> reserved(table))",
        "natural": "Provided that a table is metal, then it is reserved."
      },
      {
        "id": "Rule21",
        "formal": "(A33 ∨ A34)",
        "prover9_expression": "(polished(table) | repaired(table))",
        "natural": "A table is polished or a table is repaired."
      },
      {
        "id": "Rule22",
        "formal": "(A34 → A32)",
        "prover9_expression": "(repaired(table) -> metal(table))",
        "natural": "Whenever a table is repaired, then it is metal."
      },
      {
        "id": "Rule23",
        "formal": "(A35 → A37)",
        "prover9_expression": "(maintained(table) -> varnished(table))",
        "natural": "Should a table be maintained, then it is varnished."
      },
      {
        "id": "Rule24",
        "formal": "(A35 ∨ A36)",
        "prover9_expression": "(maintained(table) | serviced(table))",
        "natural": "Either a table is maintained or a table is serviced."
      },
      {
        "id": "Rule25",
        "formal": "(A36 → (A33 → A31))",
        "prover9_expression": "(serviced(table) -> (polished(table) -> wood(table)))",
        "natural": "Provided that a table is serviced, then if it is polished, it is wood."
      },
      {
        "id": "Rule26",
        "formal": "(A37 → A38)",
        "prover9_expression": "(varnished(table) -> finished(table))",
        "natural": "If a table is varnished, then it is finished."
      },
      {
        "id": "Rule27",
        "formal": "(A38 → A39)",
        "prover9_expression": "(finished(table) -> protected(table))",
        "natural": "Should a table be finished, then it is protected."
      },
      {
        "id": "Rule28",
        "formal": "(A39 → (A33 → A31))",
        "prover9_expression": "(protected(table) -> (polished(table) -> wood(table)))",
        "natural": "In the event that a table is protected, then if it is polished, it is wood."
      },
      {
        "id": "Rule29",
        "formal": "(A4 → A3)",
        "prover9_expression": "(available(table) -> sits(customer, table))",
        "natural": "Provided that a table is available, then a customer sits at that table."
      },
      {
        "id": "Rule30",
        "formal": "(A40 → (¬(A4 ∨ A5) → ¬A6))",
        "prover9_expression": "(broken(chair) -> (-(available(table) | reserved(table)) -> -occupied(table)))",
        "natural": "If a chair is broken, then whenever it is not the case that a table is available or reserved, the table is not occupied."
      },
      {
        "id": "Rule31",
        "formal": "(A41 → (¬(A4 ∨ A5) → ¬A6))",
        "prover9_expression": "(damaged(table) -> (-(available(table) | reserved(table)) -> -occupied(table)))",
        "natural": "Under the condition that a table is damaged, then if it is not the case that a table is available or reserved, the table is not occupied."
      },
      {
        "id": "Rule32",
        "formal": "(A42 ∨ (A40 ∨ A41))",
        "prover9_expression": "(unsafe(furniture) | (broken(chair) | damaged(table)))",
        "natural": "Furniture is unsafe, or a chair is broken, or a table is damaged."
      },
      {
        "id": "Rule33",
        "formal": "(A43 → ¬A42)",
        "prover9_expression": "(replaced(manager, furniture) -> -unsafe(furniture))",
        "natural": "Should a manager replace furniture, then it is not the case that the furniture is unsafe."
      },
      {
        "id": "Rule34",
        "formal": "(A44 → A43)",
        "prover9_expression": "(ordered(manager, furniture) -> replaced(manager, furniture))",
        "natural": "Provided that a manager orders furniture, then the manager replaces furniture."
      },
      {
        "id": "Rule35",
        "formal": "(A45 → (A11 ∨ A12))",
        "prover9_expression": "(local(ingredient) -> (fresh(ingredient) | stored(ingredient)))",
        "natural": "If an ingredient is local, then it is fresh or stored."
      },
      {
        "id": "Rule36",
        "formal": "(A45 ∨ A46)",
        "prover9_expression": "(local(ingredient) | imported(ingredient))",
        "natural": "Either an ingredient is local or an ingredient is imported."
      },
      {
        "id": "Rule37",
        "formal": "(A49 → (¬(¬(A46 → (A11 ∨ A12)) → ¬A47) → A48))",
        "prover9_expression": "(budgeted(manager, cost) -> (-(-(imported(ingredient) -> (fresh(ingredient) | stored(ingredient))) -> -expensive(ingredient)) -> affordable(ingredient)))",
        "natural": "In the event that a manager budgets a cost, then if it is not the case that the absence of an imported ingredient implying it is fresh or stored leads to the ingredient not being expensive, the ingredient is affordable."
      },
      {
        "id": "Rule38",
        "formal": "(A49 ∨ A50)",
        "prover9_expression": "(budgeted(manager, cost) | approved(owner, cost))",
        "natural": "A manager budgets a cost or an owner approves a cost."
      },
      {
        "id": "Rule39",
        "formal": "(A5 → (A2 → ¬A1))",
        "prover9_expression": "(reserved(table) -> (pays(customer, bill) -> -orders(customer, food)))",
        "natural": "Should a table be reserved, then if a customer pays a bill, the customer does not order a food."
      },
      {
        "id": "Rule40",
        "formal": "(A50 → (¬(¬(A46 → (A11 ∨ A12)) → ¬A47) → A48))",
        "prover9_expression": "(approved(owner, cost) -> (-(-(imported(ingredient) -> (fresh(ingredient) | stored(ingredient))) -> -expensive(ingredient)) -> affordable(ingredient)))",
        "natural": "Under the condition that an owner approves a cost, then if it is not the case that the absence of an imported ingredient implying it is fresh or stored leads to the ingredient not being expensive, the ingredient is affordable."
      },
      {
        "id": "Rule41",
        "formal": "(A9 → (A8 → G))",
        "prover9_expression": "(cooked(chef, food) -> (served(food, customer) -> satisfied(customer)))",
        "natural": "If a chef cooks a food, then whenever that food is served to a customer, the customer becomes satisfied."
      },
      {
        "id": "Rule42",
        "formal": "(¬(A19 ∨ A18) → ¬A20)",
        "prover9_expression": "(-(contaminated(ingredient) | inspected(chef, ingredient)) -> -discarded(ingredient))",
        "natural": "Provided that it is not the case that an ingredient is contaminated or a chef inspects an ingredient, then it is not the case that the ingredient is discarded."
      },
      {
        "id": "Rule43",
        "formal": "(¬(A4 ∨ A5) → A6)",
        "prover9_expression": "(-(available(table) | reserved(table)) -> occupied(table))",
        "natural": "Under the condition that it is not the case that a table is available or reserved, then the table is occupied."
      },
      {
        "id": "Rule44",
        "formal": "(¬(A46 → (A11 ∨ A12)) → A47)",
        "prover9_expression": "(-(imported(ingredient) -> (fresh(ingredient) | stored(ingredient))) -> expensive(ingredient))",
        "natural": "If it is not the case that an imported ingredient implies it is fresh or stored, then the ingredient is expensive."
      },
      {
        "id": "Rule45",
        "formal": "(¬(¬(A4 ∨ A5) → ¬A6) → A7)",
        "prover9_expression": "(-(-(available(table) | reserved(table)) -> -occupied(table)) -> assigned(waiter, table))",
        "natural": "Whenever it is not the case that the absence of a table being available or reserved leads to the table not being occupied, then a waiter is assigned to the table."
      },
      {
        "id": "Rule46",
        "formal": "(¬(¬(A4 ∨ A5) → ¬A6) → ¬A7)",
        "prover9_expression": "(-(-(available(table) | reserved(table)) -> -occupied(table)) -> -assigned(waiter, table))",
        "natural": "Should it not be the case that the absence of a table being available or reserved leads to the table not being occupied, then it is not the case that a waiter is assigned to the table."
      },
      {
        "id": "Rule47",
        "formal": "(¬(¬(A46 → (A11 ∨ A12)) → ¬A47) → ¬A48)",
        "prover9_expression": "(-(-(imported(ingredient) -> (fresh(ingredient) | stored(ingredient))) -> -expensive(ingredient)) -> -affordable(ingredient))",
        "natural": "In the event that it is not the case that the absence of an imported ingredient implying it is fresh or stored leads to the ingredient not being expensive, then it is not the case that the ingredient is affordable."
      },
      {
        "id": "Rule48",
        "formal": "(¬G → A1)",
        "prover9_expression": "(-satisfied(customer) -> orders(customer, food))",
        "natural": "Provided that a customer is not satisfied, then the customer orders a food."
      },
      {
        "id": "Rule49",
        "formal": "(¬G → A2)",
        "prover9_expression": "(-satisfied(customer) -> pays(customer, bill))",
        "natural": "Should a customer not be satisfied, then the customer pays a bill."
      }
    ],
    "facts": [
      {
        "id": "Fact1",
        "formal": "A23",
        "prover9_expression": "clean(table)",
        "natural": "A table is clean."
      },
      {
        "id": "Fact2",
        "formal": "A44",
        "prover9_expression": "ordered(manager, furniture)",
        "natural": "A manager orders furniture."
      },
      {
        "id": "Fact3",
        "formal": "A8",
        "prover9_expression": "served(food, customer)",
        "natural": "A food is served to a customer."
      },
      {
        "id": "Fact4",
        "formal": "¬A15",
        "prover9_expression": "-expired(ingredient)",
        "natural": "It is not the case that an ingredient is expired."
      },
      {
        "id": "Fact5",
        "formal": "¬A19",
        "prover9_expression": "-contaminated(ingredient)",
        "natural": "It is not the case that an ingredient is contaminated."
      },
      {
        "id": "Fact6",
        "formal": "¬A27",
        "prover9_expression": "-dirty(table)",
        "natural": "It is not the case that a table is dirty."
      },
      {
        "id": "Fact7",
        "formal": "¬A28",
        "prover9_expression": "-scheduled(cleaner, shift)",
        "natural": "It is not the case that a cleaner is scheduled for a shift."
      },
      {
        "id": "Fact8",
        "formal": "¬A3",
        "prover9_expression": "-sits(customer, table)",
        "natural": "It is not the case that a customer sits at a table."
      }
    ]
  },
  "target": {
    "formal": "G",
    "prover9": "G",
    "prover9_expression": "satisfied(customer)",
    "natural": "A customer is satisfied."
  },
  "solutions": [
    {
      "id": 1,
      "family_id": 1,
      "path_type": "core",
      "branch_from": null,
      "steps": [
        {
          "step_number": 1,
          "rule_applied": "RAA",
          "premises_used": [
            "(-(-(A4 | A5) -> -A6) -> A7)",
            "(-(-(A4 | A5) -> -A6) -> -A7)"
          ],
          "conclusion": "(-(A4 | A5) -> -A6)",
          "natural": "Should it not be the case that a table is available or reserved, then the table is not occupied."
        },
        {
          "step_number": 2,
          "rule_applied": "RAA",
          "premises_used": [
            "(-(A4 | A5) -> A6)",
            "(-(A4 | A5) -> -A6)"
          ],
          "conclusion": "(A4 | A5)",
          "natural": "Either a table is available or a table is reserved."
        },
        {
          "step_number": 3,
          "rule_applied": "CD",
          "premises_used": [
            "(A4 -> A3)",
            "(A5 -> (A2 -> -A1))",
            "(A4 | A5)"
          ],
          "conclusion": "(A3 | (A2 -> -A1))",
          "natural": "A customer sits at a table, or if a customer pays a bill, then the customer does not order a food."
        },
        {
          "step_number": 4,
          "rule_applied": "DS",
          "premises_used": [
            "(A3 | (A2 -> -A1))",
            "-A3"
          ],
          "conclusion": "(A2 -> -A1)",
          "natural": "Whenever a customer pays a bill, then it is not the case that the customer orders a food."
        },
        {
          "step_number": 5,
          "rule_applied": "HS",
          "premises_used": [
            "(-G -> A2)",
            "(A2 -> -A1)"
          ],
          "conclusion": "(-G -> -A1)",
          "natural": "Whenever a customer is not satisfied, then it is not the case that the customer orders a food."
        },
        {
          "step_number": 6,
          "rule_applied": "RAA",
          "premises_used": [
            "(-G -> A1)",
            "(-G -> -A1)"
          ],
          "conclusion": "G",
          "natural": "A customer is satisfied."
        }
      ]
    },
    {
      "id": 2,
      "family_id": 2,
      "path_type": "core",
      "branch_from": null,
      "steps": [
        {
          "step_number": 1,
          "rule_applied": "DS",
          "premises_used": [
            "(A15 | (A13 | A14))",
            "-A15"
          ],
          "conclusion": "(A13 | A14)",
          "natural": "A supplier delivers an ingredient or a manager purchases an ingredient."
        },
        {
          "step_number": 2,
          "rule_applied": "CD",
          "premises_used": [
            "(A13 -> A11)",
            "(A14 -> A12)",
            "(A13 | A14)"
          ],
          "conclusion": "(A11 | A12)",
          "natural": "Either an ingredient is fresh or an ingredient is stored."
        },
        {
          "step_number": 3,
          "rule_applied": "CD",
          "premises_used": [
            "(A11 -> A9)",
            "(A12 -> A10)",
            "(A11 | A12)"
          ],
          "conclusion": "(A9 | A10)",
          "natural": "Either a chef cooks a food or a chef prepares a food."
        },
        {
          "step_number": 4,
          "rule_applied": "DE",
          "premises_used": [
            "(A9 | A10)",
            "(A9 -> (A8 -> G))",
            "(A10 -> (A8 -> G))"
          ],
          "conclusion": "(A8 -> G)",
          "natural": "Provided that a food is served to a customer, then the customer is satisfied."
        },
        {
          "step_number": 5,
          "rule_applied": "MP",
          "premises_used": [
            "(A8 -> G)",
            "A8"
          ],
          "conclusion": "G",
          "natural": "A customer is satisfied."
        }
      ]
    },
    {
      "id": 3,
      "family_id": 1,
      "path_type": "branch",
      "branch_from": 0,
      "steps": [
        {
          "step_number": 1,
          "rule_applied": "DE",
          "premises_used": [
            "(A21 | A22)",
            "(A21 -> (-(A19 | A18) -> A20))",
            "(A22 -> (-(A19 | A18) -> A20))"
          ],
          "conclusion": "(-(A19 | A18) -> A20)",
          "natural": "Should it not be the case that an ingredient is contaminated or a chef inspects an ingredient, then the ingredient is discarded."
        },
        {
          "step_number": 2,
          "rule_applied": "RAA",
          "premises_used": [
            "(-(A19 | A18) -> A20)",
            "(-(A19 | A18) -> -A20)"
          ],
          "conclusion": "(A19 | A18)",
          "natural": "Either an ingredient is contaminated or a chef inspects an ingredient."
        },
        {
          "step_number": 3,
          "rule_applied": "DS",
          "premises_used": [
            "(A19 | A18)",
            "-A19"
          ],
          "conclusion": "A18",
          "natural": "A chef inspects an ingredient."
        },
        {
          "step_number": 4,
          "rule_applied": "MP",
          "premises_used": [
            "(A18 -> A17)",
            "A18"
          ],
          "conclusion": "A17",
          "natural": "A manager checks an ingredient."
        },
        {
          "step_number": 5,
          "rule_applied": "MP",
          "premises_used": [
            "(A17 -> -A16)",
            "A17"
          ],
          "conclusion": "-A16",
          "natural": "It is not the case that an ingredient is spoiled."
        },
        {
          "step_number": 6,
          "rule_applied": "DS",
          "premises_used": [
            "(A16 | (-(A4 | A5) -> -A6))",
            "-A16"
          ],
          "conclusion": "(-(A4 | A5) -> -A6)",
          "natural": "Should it not be the case that a table is available or reserved, then the table is not occupied."
        },
        {
          "step_number": 7,
          "rule_applied": "RAA",
          "premises_used": [
            "(-(A4 | A5) -> A6)",
            "(-(A4 | A5) -> -A6)"
          ],
          "conclusion": "(A4 | A5)",
          "natural": "Either a table is available or a table is reserved."
        },
        {
          "step_number": 8,
          "rule_applied": "CD",
          "premises_used": [
            "(A4 -> A3)",
            "(A5 -> (A2 -> -A1))",
            "(A4 | A5)"
          ],
          "conclusion": "(A3 | (A2 -> -A1))",
          "natural": "A customer sits at a table, or if a customer pays a bill, then the customer does not order a food."
        },
        {
          "step_number": 9,
          "rule_applied": "DS",
          "premises_used": [
            "(A3 | (A2 -> -A1))",
            "-A3"
          ],
          "conclusion": "(A2 -> -A1)",
          "natural": "Whenever a customer pays a bill, then it is not the case that the customer orders a food."
        },
        {
          "step_number": 10,
          "rule_applied": "HS",
          "premises_used": [
            "(-G -> A2)",
            "(A2 -> -A1)"
          ],
          "conclusion": "(-G -> -A1)",
          "natural": "Whenever a customer is not satisfied, then it is not the case that the customer orders a food."
        },
        {
          "step_number": 11,
          "rule_applied": "RAA",
          "premises_used": [
            "(-G -> A1)",
            "(-G -> -A1)"
          ],
          "conclusion": "G",
          "natural": "A customer is satisfied."
        }
      ]
    },
    {
      "id": 4,
      "family_id": 1,
      "path_type": "branch",
      "branch_from": 1,
      "steps": [
        {
          "step_number": 1,
          "rule_applied": "CD",
          "premises_used": [
            "(A29 -> A28)",
            "(A30 -> (-(A26 -> (A4 | A5)) -> A27))",
            "(A29 | A30)"
          ],
          "conclusion": "(A28 | (-(A26 -> (A4 | A5)) -> A27))",
          "natural": "A cleaner is scheduled for a shift, or if it is not the case that a ready table implies it is available or reserved, then the table is dirty."
        },
        {
          "step_number": 2,
          "rule_applied": "DS",
          "premises_used": [
            "(A28 | (-(A26 -> (A4 | A5)) -> A27))",
            "-A28"
          ],
          "conclusion": "(-(A26 -> (A4 | A5)) -> A27)",
          "natural": "In the event that it is not the case that a ready table implies it is available or reserved, then the table is dirty."
        },
        {
          "step_number": 3,
          "rule_applied": "MT",
          "premises_used": [
            "(-(A26 -> (A4 | A5)) -> A27)",
            "-A27"
          ],
          "conclusion": "(A26 -> (A4 | A5))",
          "natural": "Should a table be ready, then it is available or reserved."
        },
        {
          "step_number": 4,
          "rule_applied": "HS",
          "premises_used": [
            "(A25 -> A26)",
            "(A26 -> (A4 | A5))"
          ],
          "conclusion": "(A25 -> (A4 | A5))",
          "natural": "If a table is sanitized, then it is available or reserved."
        },
        {
          "step_number": 5,
          "rule_applied": "HS",
          "premises_used": [
            "(A24 -> A25)",
            "(A25 -> (A4 | A5))"
          ],
          "conclusion": "(A24 -> (A4 | A5))",
          "natural": "Under the condition that a cleaner wipes a table, then that table is available or reserved."
        },
        {
          "step_number": 6,
          "rule_applied": "HS",
          "premises_used": [
            "(A23 -> A24)",
            "(A24 -> (A4 | A5))"
          ],
          "conclusion": "(A23 -> (A4 | A5))",
          "natural": "Provided that a table is clean, then the table is available or reserved."
        },
        {
          "step_number": 7,
          "rule_applied": "MP",
          "premises_used": [
            "(A23 -> (A4 | A5))",
            "A23"
          ],
          "conclusion": "(A4 | A5)",
          "natural": "Either a table is available or a table is reserved."
        },
        {
          "step_number": 8,
          "rule_applied": "CD",
          "premises_used": [
            "(A4 -> A3)",
            "(A5 -> (A2 -> -A1))",
            "(A4 | A5)"
          ],
          "conclusion": "(A3 | (A2 -> -A1))",
          "natural": "A customer sits at a table, or if a customer pays a bill, then the customer does not order a food."
        },
        {
          "step_number": 9,
          "rule_applied": "DS",
          "premises_used": [
            "(A3 | (A2 -> -A1))",
            "-A3"
          ],
          "conclusion": "(A2 -> -A1)",
          "natural": "Whenever a customer pays a bill, then it is not the case that the customer orders a food."
        },
        {
          "step_number": 10,
          "rule_applied": "HS",
          "premises_used": [
            "(-G -> A2)",
            "(A2 -> -A1)"
          ],
          "conclusion": "(-G -> -A1)",
          "natural": "Whenever a customer is not satisfied, then it is not the case that the customer orders a food."
        },
        {
          "step_number": 11,
          "rule_applied": "RAA",
          "premises_used": [
            "(-G -> A1)",
            "(-G -> -A1)"
          ],
          "conclusion": "G",
          "natural": "A customer is satisfied."
        }
      ]
    },
    {
      "id": 5,
      "family_id": 1,
      "path_type": "branch",
      "branch_from": 1,
      "steps": [
        {
          "step_number": 1,
          "rule_applied": "HS",
          "premises_used": [
            "(A38 -> A39)",
            "(A39 -> (A33 -> A31))"
          ],
          "conclusion": "(A38 -> (A33 -> A31))",
          "natural": "Whenever a table is finished, then if it is polished, it is wood."
        },
        {
          "step_number": 2,
          "rule_applied": "HS",
          "premises_used": [
            "(A37 -> A38)",
            "(A38 -> (A33 -> A31))"
          ],
          "conclusion": "(A37 -> (A33 -> A31))",
          "natural": "Under the condition that a table is varnished, then if it is polished, it is wood."
        },
        {
          "step_number": 3,
          "rule_applied": "HS",
          "premises_used": [
            "(A35 -> A37)",
            "(A37 -> (A33 -> A31))"
          ],
          "conclusion": "(A35 -> (A33 -> A31))",
          "natural": "In the event that a table is maintained, then if the table is polished, it is wood."
        },
        {
          "step_number": 4,
          "rule_applied": "DE",
          "premises_used": [
            "(A35 | A36)",
            "(A35 -> (A33 -> A31))",
            "(A36 -> (A33 -> A31))"
          ],
          "conclusion": "(A33 -> A31)",
          "natural": "If a table is polished, then it is wood."
        },
        {
          "step_number": 5,
          "rule_applied": "CD",
          "premises_used": [
            "(A33 -> A31)",
            "(A34 -> A32)",
            "(A33 | A34)"
          ],
          "conclusion": "(A31 | A32)",
          "natural": "Either a table is wood or a table is metal."
        },
        {
          "step_number": 6,
          "rule_applied": "CD",
          "premises_used": [
            "(A31 -> A4)",
            "(A32 -> A5)",
            "(A31 | A32)"
          ],
          "conclusion": "(A4 | A5)",
          "natural": "Either a table is available or a table is reserved."
        },
        {
          "step_number": 7,
          "rule_applied": "CD",
          "premises_used": [
            "(A4 -> A3)",
            "(A5 -> (A2 -> -A1))",
            "(A4 | A5)"
          ],
          "conclusion": "(A3 | (A2 -> -A1))",
          "natural": "A customer sits at a table, or if a customer pays a bill, then the customer does not order a food."
        },
        {
          "step_number": 8,
          "rule_applied": "DS",
          "premises_used": [
            "(A3 | (A2 -> -A1))",
            "-A3"
          ],
          "conclusion": "(A2 -> -A1)",
          "natural": "Whenever a customer pays a bill, then it is not the case that the customer orders a food."
        },
        {
          "step_number": 9,
          "rule_applied": "HS",
          "premises_used": [
            "(-G -> A2)",
            "(A2 -> -A1)"
          ],
          "conclusion": "(-G -> -A1)",
          "natural": "Whenever a customer is not satisfied, then it is not the case that the customer orders a food."
        },
        {
          "step_number": 10,
          "rule_applied": "RAA",
          "premises_used": [
            "(-G -> A1)",
            "(-G -> -A1)"
          ],
          "conclusion": "G",
          "natural": "A customer is satisfied."
        }
      ]
    },
    {
      "id": 6,
      "family_id": 1,
      "path_type": "branch",
      "branch_from": 0,
      "steps": [
        {
          "step_number": 1,
          "rule_applied": "MP",
          "premises_used": [
            "(A44 -> A43)",
            "A44"
          ],
          "conclusion": "A43",
          "natural": "A manager replaces furniture."
        },
        {
          "step_number": 2,
          "rule_applied": "MP",
          "premises_used": [
            "(A43 -> -A42)",
            "A43"
          ],
          "conclusion": "-A42",
          "natural": "It is not the case that furniture is unsafe."
        },
        {
          "step_number": 3,
          "rule_applied": "DS",
          "premises_used": [
            "(A42 | (A40 | A41))",
            "-A42"
          ],
          "conclusion": "(A40 | A41)",
          "natural": "A chair is broken or a table is damaged."
        },
        {
          "step_number": 4,
          "rule_applied": "DE",
          "premises_used": [
            "(A40 | A41)",
            "(A40 -> (-(A4 | A5) -> -A6))",
            "(A41 -> (-(A4 | A5) -> -A6))"
          ],
          "conclusion": "(-(A4 | A5) -> -A6)",
          "natural": "Should it not be the case that a table is available or reserved, then the table is not occupied."
        },
        {
          "step_number": 5,
          "rule_applied": "RAA",
          "premises_used": [
            "(-(A4 | A5) -> A6)",
            "(-(A4 | A5) -> -A6)"
          ],
          "conclusion": "(A4 | A5)",
          "natural": "Either a table is available or a table is reserved."
        },
        {
          "step_number": 6,
          "rule_applied": "CD",
          "premises_used": [
            "(A4 -> A3)",
            "(A5 -> (A2 -> -A1))",
            "(A4 | A5)"
          ],
          "conclusion": "(A3 | (A2 -> -A1))",
          "natural": "A customer sits at a table, or if a customer pays a bill, then the customer does not order a food."
        },
        {
          "step_number": 7,
          "rule_applied": "DS",
          "premises_used": [
            "(A3 | (A2 -> -A1))",
            "-A3"
          ],
          "conclusion": "(A2 -> -A1)",
          "natural": "Whenever a customer pays a bill, then it is not the case that the customer orders a food."
        },
        {
          "step_number": 8,
          "rule_applied": "HS",
          "premises_used": [
            "(-G -> A2)",
            "(A2 -> -A1)"
          ],
          "conclusion": "(-G -> -A1)",
          "natural": "Whenever a customer is not satisfied, then it is not the case that the customer orders a food."
        },
        {
          "step_number": 9,
          "rule_applied": "RAA",
          "premises_used": [
            "(-G -> A1)",
            "(-G -> -A1)"
          ],
          "conclusion": "G",
          "natural": "A customer is satisfied."
        }
      ]
    },
    {
      "id": 7,
      "family_id": 2,
      "path_type": "branch",
      "branch_from": 1,
      "steps": [
        {
          "step_number": 1,
          "rule_applied": "DE",
          "premises_used": [
            "(A49 | A50)",
            "(A49 -> (-(-(A46 -> (A11 | A12)) -> -A47) -> A48))",
            "(A50 -> (-(-(A46 -> (A11 | A12)) -> -A47) -> A48))"
          ],
          "conclusion": "(-(-(A46 -> (A11 | A12)) -> -A47) -> A48)",
          "natural": "Under the condition that it is not the case that the absence of an imported ingredient implying it is fresh or stored leads to the ingredient not being expensive, then the ingredient is affordable."
        },
        {
          "step_number": 2,
          "rule_applied": "RAA",
          "premises_used": [
            "(-(-(A46 -> (A11 | A12)) -> -A47) -> A48)",
            "(-(-(A46 -> (A11 | A12)) -> -A47) -> -A48)"
          ],
          "conclusion": "(-(A46 -> (A11 | A12)) -> -A47)",
          "natural": "Provided that it is not the case that an imported ingredient implies it is fresh or stored, then it is not the case that the ingredient is expensive."
        },
        {
          "step_number": 3,
          "rule_applied": "RAA",
          "premises_used": [
            "(-(A46 -> (A11 | A12)) -> A47)",
            "(-(A46 -> (A11 | A12)) -> -A47)"
          ],
          "conclusion": "(A46 -> (A11 | A12))",
          "natural": "Whenever an ingredient is imported, then it is fresh or stored."
        },
        {
          "step_number": 4,
          "rule_applied": "DE",
          "premises_used": [
            "(A45 | A46)",
            "(A45 -> (A11 | A12))",
            "(A46 -> (A11 | A12))"
          ],
          "conclusion": "(A11 | A12)",
          "natural": "Either an ingredient is fresh or an ingredient is stored."
        },
        {
          "step_number": 5,
          "rule_applied": "CD",
          "premises_used": [
            "(A11 -> A9)",
            "(A12 -> A10)",
            "(A11 | A12)"
          ],
          "conclusion": "(A9 | A10)",
          "natural": "Either a chef cooks a food or a chef prepares a food."
        },
        {
          "step_number": 6,
          "rule_applied": "DE",
          "premises_used": [
            "(A9 | A10)",
            "(A9 -> (A8 -> G))",
            "(A10 -> (A8 -> G))"
          ],
          "conclusion": "(A8 -> G)",
          "natural": "Provided that a food is served to a customer, then the customer is satisfied."
        },
        {
          "step_number": 7,
          "rule_applied": "MP",
          "premises_used": [
            "(A8 -> G)",
            "A8"
          ],
          "conclusion": "G",
          "natural": "A customer is satisfied."
        }
      ]
    }
  ],
  "translations": {
    "domain_theme": "Restaurant Operation",
    "atomic_facts": {
      "A1": "orders(customer, food)",
      "A2": "pays(customer, bill)",
      "A3": "sits(customer, table)",
      "A4": "available(table)",
      "A5": "reserved(table)",
      "A6": "occupied(table)",
      "A7": "assigned(waiter, table)",
      "A8": "served(food, customer)",
      "A9": "cooked(chef, food)",
      "A10": "prepared(chef, food)",
      "A11": "fresh(ingredient)",
      "A12": "stored(ingredient)",
      "A13": "delivered(supplier, ingredient)",
      "A14": "purchased(manager, ingredient)",
      "A15": "expired(ingredient)",
      "A16": "spoiled(ingredient)",
      "A17": "checked(manager, ingredient)",
      "A18": "inspected(chef, ingredient)",
      "A19": "contaminated(ingredient)",
      "A20": "discarded(ingredient)",
      "A21": "found(inspector, problem)",
      "A22": "reported(staff, problem)",
      "A23": "clean(table)",
      "A24": "wiped(cleaner, table)",
      "A25": "sanitized(table)",
      "A26": "ready(table)",
      "A27": "dirty(table)",
      "A28": "scheduled(cleaner, shift)",
      "A29": "arrived(cleaner, work)",
      "A30": "called(manager, cleaner)",
      "A31": "wood(table)",
      "A32": "metal(table)",
      "A33": "polished(table)",
      "A34": "repaired(table)",
      "A35": "maintained(table)",
      "A36": "serviced(table)",
      "A37": "varnished(table)",
      "A38": "finished(table)",
      "A39": "protected(table)",
      "A40": "broken(chair)",
      "A41": "damaged(table)",
      "A42": "unsafe(furniture)",
      "A43": "replaced(manager, furniture)",
      "A44": "ordered(manager, furniture)",
      "A45": "local(ingredient)",
      "A46": "imported(ingredient)",
      "A47": "expensive(ingredient)",
      "A48": "affordable(ingredient)",
      "A49": "budgeted(manager, cost)",
      "A50": "approved(owner, cost)",
      "G": "satisfied(customer)"
    },
    "natural_facts": {
      "A1": "A customer orders a food.",
      "A2": "A customer pays a bill.",
      "A3": "A customer sits at a table.",
      "A4": "A table is available.",
      "A5": "A table is reserved.",
      "A6": "A table is occupied.",
      "A7": "A waiter is assigned to a table.",
      "A8": "A food is served to a customer.",
      "A9": "A chef cooks a food.",
      "A10": "A chef prepares a food.",
      "A11": "An ingredient is fresh.",
      "A12": "An ingredient is stored.",
      "A13": "A supplier delivers an ingredient.",
      "A14": "A manager purchases an ingredient.",
      "A15": "An ingredient is expired.",
      "A16": "An ingredient is spoiled.",
      "A17": "A manager checks an ingredient.",
      "A18": "A chef inspects an ingredient.",
      "A19": "An ingredient is contaminated.",
      "A20": "An ingredient is discarded.",
      "A21": "An inspector finds a problem.",
      "A22": "A staff reports a problem.",
      "A23": "A table is clean.",
      "A24": "A cleaner wipes a table.",
      "A25": "A table is sanitized.",
      "A26": "A table is ready.",
      "A27": "A table is dirty.",
      "A28": "A cleaner is scheduled for a shift.",
      "A29": "A cleaner arrives at work.",
      "A30": "A manager calls a cleaner.",
      "A31": "A table is wood.",
      "A32": "A table is metal.",
      "A33": "A table is polished.",
      "A34": "A table is repaired.",
      "A35": "A table is maintained.",
      "A36": "A table is serviced.",
      "A37": "A table is varnished.",
      "A38": "A table is finished.",
      "A39": "A table is protected.",
      "A40": "A chair is broken.",
      "A41": "A table is damaged.",
      "A42": "Furniture is unsafe.",
      "A43": "A manager replaces furniture.",
      "A44": "A manager orders furniture.",
      "A45": "An ingredient is local.",
      "A46": "An ingredient is imported.",
      "A47": "An ingredient is expensive.",
      "A48": "An ingredient is affordable.",
      "A49": "A manager budgets a cost.",
      "A50": "An owner approves a cost.",
      "G": "A customer is satisfied."
    },
    "prover9_expressions": [
      "(prepared(chef, food) -> (served(food, customer) -> satisfied(customer)))",
      "(fresh(ingredient) -> cooked(chef, food))",
      "(fresh(ingredient) | stored(ingredient))",
      "(stored(ingredient) -> prepared(chef, food))",
      "(delivered(supplier, ingredient) -> fresh(ingredient))",
      "(delivered(supplier, ingredient) | purchased(manager, ingredient))",
      "(purchased(manager, ingredient) -> stored(ingredient))",
      "(expired(ingredient) | (delivered(supplier, ingredient) | purchased(manager, ingredient)))",
      "(spoiled(ingredient) | (-(available(table) | reserved(table)) -> -occupied(table)))",
      "(checked(manager, ingredient) -> -spoiled(ingredient))",
      "(inspected(chef, ingredient) -> checked(manager, ingredient))",
      "(contaminated(ingredient) | inspected(chef, ingredient))",
      "(pays(customer, bill) -> -orders(customer, food))",
      "(found(inspector, problem) -> (-(contaminated(ingredient) | inspected(chef, ingredient)) -> discarded(ingredient)))",
      "(found(inspector, problem) | reported(staff, problem))",
      "(reported(staff, problem) -> (-(contaminated(ingredient) | inspected(chef, ingredient)) -> discarded(ingredient)))",
      "(clean(table) -> (available(table) | reserved(table)))",
      "(clean(table) -> wiped(cleaner, table))",
      "(wiped(cleaner, table) -> (available(table) | reserved(table)))",
      "(wiped(cleaner, table) -> sanitized(table))",
      "(sanitized(table) -> (available(table) | reserved(table)))",
      "(sanitized(table) -> ready(table))",
      "(ready(table) -> (available(table) | reserved(table)))",
      "(scheduled(cleaner, shift) | (-(ready(table) -> (available(table) | reserved(table))) -> dirty(table)))",
      "(arrived(cleaner, work) -> scheduled(cleaner, shift))",
      "(arrived(cleaner, work) | called(manager, cleaner))",
      "(sits(customer, table) | (pays(customer, bill) -> -orders(customer, food)))",
      "(called(manager, cleaner) -> (-(ready(table) -> (available(table) | reserved(table))) -> dirty(table)))",
      "(wood(table) -> available(table))",
      "(wood(table) | metal(table))",
      "(metal(table) -> reserved(table))",
      "(polished(table) -> wood(table))",
      "(polished(table) | repaired(table))",
      "(repaired(table) -> metal(table))",
      "(maintained(table) -> (polished(table) -> wood(table)))",
      "(maintained(table) -> varnished(table))",
      "(maintained(table) | serviced(table))",
      "(serviced(table) -> (polished(table) -> wood(table)))",
      "(varnished(table) -> (polished(table) -> wood(table)))",
      "(varnished(table) -> finished(table))",
      "(finished(table) -> (polished(table) -> wood(table)))",
      "(finished(table) -> protected(table))",
      "(protected(table) -> (polished(table) -> wood(table)))",
      "(available(table) -> sits(customer, table))",
      "(available(table) | reserved(table))",
      "(broken(chair) -> (-(available(table) | reserved(table)) -> -occupied(table)))",
      "(broken(chair) | damaged(table))",
      "(damaged(table) -> (-(available(table) | reserved(table)) -> -occupied(table)))",
      "(unsafe(furniture) | (broken(chair) | damaged(table)))",
      "(replaced(manager, furniture) -> -unsafe(furniture))",
      "(ordered(manager, furniture) -> replaced(manager, furniture))",
      "(local(ingredient) -> (fresh(ingredient) | stored(ingredient)))",
      "(local(ingredient) | imported(ingredient))",
      "(imported(ingredient) -> (fresh(ingredient) | stored(ingredient)))",
      "(budgeted(manager, cost) -> (-(-(imported(ingredient) -> (fresh(ingredient) | stored(ingredient))) -> -expensive(ingredient)) -> affordable(ingredient)))",
      "(budgeted(manager, cost) | approved(owner, cost))",
      "(reserved(table) -> (pays(customer, bill) -> -orders(customer, food)))",
      "(approved(owner, cost) -> (-(-(imported(ingredient) -> (fresh(ingredient) | stored(ingredient))) -> -expensive(ingredient)) -> affordable(ingredient)))",
      "(served(food, customer) -> satisfied(customer))",
      "(cooked(chef, food) -> (served(food, customer) -> satisfied(customer)))",
      "(cooked(chef, food) | prepared(chef, food))",
      "(-(contaminated(ingredient) | inspected(chef, ingredient)) -> discarded(ingredient))",
      "(-(contaminated(ingredient) | inspected(chef, ingredient)) -> -discarded(ingredient))",
      "(-(ready(table) -> (available(table) | reserved(table))) -> dirty(table))",
      "(-(available(table) | reserved(table)) -> occupied(table))",
      "(-(available(table) | reserved(table)) -> -occupied(table))",
      "(-(imported(ingredient) -> (fresh(ingredient) | stored(ingredient))) -> expensive(ingredient))",
      "(-(imported(ingredient) -> (fresh(ingredient) | stored(ingredient))) -> -expensive(ingredient))",
      "(-(-(available(table) | reserved(table)) -> -occupied(table)) -> assigned(waiter, table))",
      "(-(-(available(table) | reserved(table)) -> -occupied(table)) -> -assigned(waiter, table))",
      "(-(-(imported(ingredient) -> (fresh(ingredient) | stored(ingredient))) -> -expensive(ingredient)) -> affordable(ingredient))",
      "(-(-(imported(ingredient) -> (fresh(ingredient) | stored(ingredient))) -> -expensive(ingredient)) -> -affordable(ingredient))",
      "(-satisfied(customer) -> orders(customer, food))",
      "(-satisfied(customer) -> pays(customer, bill))",
      "(-satisfied(customer) -> -orders(customer, food))",
      "checked(manager, ingredient)",
      "inspected(chef, ingredient)",
      "clean(table)",
      "replaced(manager, furniture)",
      "ordered(manager, furniture)",
      "served(food, customer)",
      "satisfied(customer)",
      "-expired(ingredient)",
      "-spoiled(ingredient)",
      "-contaminated(ingredient)",
      "-dirty(table)",
      "-scheduled(cleaner, shift)",
      "-sits(customer, table)",
      "-unsafe(furniture)"
    ],
    "natural_expressions": [
      "Provided that a chef prepares a food, then if that food is served to a customer, the customer becomes satisfied.",
      "Under the condition that an ingredient is fresh, then a chef cooks a food.",
      "Either an ingredient is fresh or an ingredient is stored.",
      "Whenever an ingredient is stored, then a chef prepares a food.",
      "If a supplier delivers an ingredient, then that ingredient is fresh.",
      "A supplier delivers an ingredient or a manager purchases an ingredient.",
      "In the event that a manager purchases an ingredient, then that ingredient is stored.",
      "Either an ingredient is expired, or a supplier delivers an ingredient, or a manager purchases an ingredient.",
      "An ingredient is spoiled, or if it is not the case that a table is available or reserved, then the table is not occupied.",
      "Should a manager check an ingredient, then it is not the case that the ingredient is spoiled.",
      "Provided that a chef inspects an ingredient, then a manager checks that ingredient.",
      "Either an ingredient is contaminated or a chef inspects an ingredient.",
      "Whenever a customer pays a bill, then it is not the case that the customer orders a food.",
      "If an inspector finds a problem, then whenever it is not the case that an ingredient is contaminated or a chef inspects an ingredient, the ingredient is discarded.",
      "An inspector finds a problem or staff reports a problem.",
      "In the event that staff reports a problem, then if it is not the case that an ingredient is contaminated or a chef inspects an ingredient, the ingredient is discarded.",
      "Provided that a table is clean, then the table is available or reserved.",
      "Should a table be clean, then a cleaner wipes that table.",
      "Under the condition that a cleaner wipes a table, then that table is available or reserved.",
      "Whenever a cleaner wipes a table, then the table is sanitized.",
      "If a table is sanitized, then it is available or reserved.",
      "Provided that a table is sanitized, then it is ready.",
      "Should a table be ready, then it is available or reserved.",
      "A cleaner is scheduled for a shift, or if it is not the case that a ready table implies it is available or reserved, then the table is dirty.",
      "In the event that a cleaner arrives at work, then the cleaner is scheduled for a shift.",
      "Either a cleaner arrives at work or a manager calls a cleaner.",
      "A customer sits at a table, or if a customer pays a bill, then the customer does not order a food.",
      "Should a manager call a cleaner, then if it is not the case that a ready table implies it is available or reserved, the table is dirty.",
      "Under the condition that a table is wood, then it is available.",
      "Either a table is wood or a table is metal.",
      "Provided that a table is metal, then it is reserved.",
      "If a table is polished, then it is wood.",
      "A table is polished or a table is repaired.",
      "Whenever a table is repaired, then it is metal.",
      "In the event that a table is maintained, then if the table is polished, it is wood.",
      "Should a table be maintained, then it is varnished.",
      "Either a table is maintained or a table is serviced.",
      "Provided that a table is serviced, then if it is polished, it is wood.",
      "Under the condition that a table is varnished, then if it is polished, it is wood.",
      "If a table is varnished, then it is finished.",
      "Whenever a table is finished, then if it is polished, it is wood.",
      "Should a table be finished, then it is protected.",
      "In the event that a table is protected, then if it is polished, it is wood.",
      "Provided that a table is available, then a customer sits at that table.",
      "Either a table is available or a table is reserved.",
      "If a chair is broken, then whenever it is not the case that a table is available or reserved, the table is not occupied.",
      "A chair is broken or a table is damaged.",
      "Under the condition that a table is damaged, then if it is not the case that a table is available or reserved, the table is not occupied.",
      "Furniture is unsafe, or a chair is broken, or a table is damaged.",
      "Should a manager replace furniture, then it is not the case that the furniture is unsafe.",
      "Provided that a manager orders furniture, then the manager replaces furniture.",
      "If an ingredient is local, then it is fresh or stored.",
      "Either an ingredient is local or an ingredient is imported.",
      "Whenever an ingredient is imported, then it is fresh or stored.",
      "In the event that a manager budgets a cost, then if it is not the case that the absence of an imported ingredient implying it is fresh or stored leads to the ingredient not being expensive, the ingredient is affordable.",
      "A manager budgets a cost or an owner approves a cost.",
      "Should a table be reserved, then if a customer pays a bill, the customer does not order a food.",
      "Under the condition that an owner approves a cost, then if it is not the case that the absence of an imported ingredient implying it is fresh or stored leads to the ingredient not being expensive, the ingredient is affordable.",
      "Provided that a food is served to a customer, then the customer is satisfied.",
      "If a chef cooks a food, then whenever that food is served to a customer, the customer becomes satisfied.",
      "Either a chef cooks a food or a chef prepares a food.",
      "Should it not be the case that an ingredient is contaminated or a chef inspects an ingredient, then the ingredient is discarded.",
      "Provided that it is not the case that an ingredient is contaminated or a chef inspects an ingredient, then it is not the case that the ingredient is discarded.",
      "In the event that it is not the case that a ready table implies it is available or reserved, then the table is dirty.",
      "Under the condition that it is not the case that a table is available or reserved, then the table is occupied.",
      "Should it not be the case that a table is available or reserved, then the table is not occupied.",
      "If it is not the case that an imported ingredient implies it is fresh or stored, then the ingredient is expensive.",
      "Provided that it is not the case that an imported ingredient implies it is fresh or stored, then it is not the case that the ingredient is expensive.",
      "Whenever it is not the case that the absence of a table being available or reserved leads to the table not being occupied, then a waiter is assigned to the table.",
      "Should it not be the case that the absence of a table being available or reserved leads to the table not being occupied, then it is not the case that a waiter is assigned to the table.",
      "Under the condition that it is not the case that the absence of an imported ingredient implying it is fresh or stored leads to the ingredient not being expensive, then the ingredient is affordable.",
      "In the event that it is not the case that the absence of an imported ingredient implying it is fresh or stored leads to the ingredient not being expensive, then it is not the case that the ingredient is affordable.",
      "Provided that a customer is not satisfied, then the customer orders a food.",
      "Should a customer not be satisfied, then the customer pays a bill.",
      "Whenever a customer is not satisfied, then it is not the case that the customer orders a food.",
      "A manager checks an ingredient.",
      "A chef inspects an ingredient.",
      "A table is clean.",
      "A manager replaces furniture.",
      "A manager orders furniture.",
      "A food is served to a customer.",
      "A customer is satisfied.",
      "It is not the case that an ingredient is expired.",
      "It is not the case that an ingredient is spoiled.",
      "It is not the case that an ingredient is contaminated.",
      "It is not the case that a table is dirty.",
      "It is not the case that a cleaner is scheduled for a shift.",
      "It is not the case that a customer sits at a table.",
      "It is not the case that furniture is unsafe."
    ],
    "node_mappings": {
      "(A10 → (A8 → G))": {
        "formal": "(A10 → (A8 → G))",
        "prover9": "(A10 -> (A8 -> G))",
        "prover9_expression": "(prepared(chef, food) -> (served(food, customer) -> satisfied(customer)))",
        "natural": "Provided that a chef prepares a food, then if that food is served to a customer, the customer becomes satisfied."
      },
      "(A11 → A9)": {
        "formal": "(A11 → A9)",
        "prover9": "(A11 -> A9)",
        "prover9_expression": "(fresh(ingredient) -> cooked(chef, food))",
        "natural": "Under the condition that an ingredient is fresh, then a chef cooks a food."
      },
      "(A11 ∨ A12)": {
        "formal": "(A11 ∨ A12)",
        "prover9": "(A11 | A12)",
        "prover9_expression": "(fresh(ingredient) | stored(ingredient))",
        "natural": "Either an ingredient is fresh or an ingredient is stored."
      },
      "(A12 → A10)": {
        "formal": "(A12 → A10)",
        "prover9": "(A12 -> A10)",
        "prover9_expression": "(stored(ingredient) -> prepared(chef, food))",
        "natural": "Whenever an ingredient is stored, then a chef prepares a food."
      },
      "(A13 → A11)": {
        "formal": "(A13 → A11)",
        "prover9": "(A13 -> A11)",
        "prover9_expression": "(delivered(supplier, ingredient) -> fresh(ingredient))",
        "natural": "If a supplier delivers an ingredient, then that ingredient is fresh."
      },
      "(A13 ∨ A14)": {
        "formal": "(A13 ∨ A14)",
        "prover9": "(A13 | A14)",
        "prover9_expression": "(delivered(supplier, ingredient) | purchased(manager, ingredient))",
        "natural": "A supplier delivers an ingredient or a manager purchases an ingredient."
      },
      "(A14 → A12)": {
        "formal": "(A14 → A12)",
        "prover9": "(A14 -> A12)",
        "prover9_expression": "(purchased(manager, ingredient) -> stored(ingredient))",
        "natural": "In the event that a manager purchases an ingredient, then that ingredient is stored."
      },
      "(A15 ∨ (A13 ∨ A14))": {
        "formal": "(A15 ∨ (A13 ∨ A14))",
        "prover9": "(A15 | (A13 | A14))",
        "prover9_expression": "(expired(ingredient) | (delivered(supplier, ingredient) | purchased(manager, ingredient)))",
        "natural": "Either an ingredient is expired, or a supplier delivers an ingredient, or a manager purchases an ingredient."
      },
      "(A16 ∨ (¬(A4 ∨ A5) → ¬A6))": {
        "formal": "(A16 ∨ (¬(A4 ∨ A5) → ¬A6))",
        "prover9": "(A16 | (-(A4 | A5) -> -A6))",
        "prover9_expression": "(spoiled(ingredient) | (-(available(table) | reserved(table)) -> -occupied(table)))",
        "natural": "An ingredient is spoiled, or if it is not the case that a table is available or reserved, then the table is not occupied."
      },
      "(A17 → ¬A16)": {
        "formal": "(A17 → ¬A16)",
        "prover9": "(A17 -> -A16)",
        "prover9_expression": "(checked(manager, ingredient) -> -spoiled(ingredient))",
        "natural": "Should a manager check an ingredient, then it is not the case that the ingredient is spoiled."
      },
      "(A18 → A17)": {
        "formal": "(A18 → A17)",
        "prover9": "(A18 -> A17)",
        "prover9_expression": "(inspected(chef, ingredient) -> checked(manager, ingredient))",
        "natural": "Provided that a chef inspects an ingredient, then a manager checks that ingredient."
      },
      "(A19 ∨ A18)": {
        "formal": "(A19 ∨ A18)",
        "prover9": "(A19 | A18)",
        "prover9_expression": "(contaminated(ingredient) | inspected(chef, ingredient))",
        "natural": "Either an ingredient is contaminated or a chef inspects an ingredient."
      },
      "(A2 → ¬A1)": {
        "formal": "(A2 → ¬A1)",
        "prover9": "(A2 -> -A1)",
        "prover9_expression": "(pays(customer, bill) -> -orders(customer, food))",
        "natural": "Whenever a customer pays a bill, then it is not the case that the customer orders a food."
      },
      "(A21 → (¬(A19 ∨ A18) → A20))": {
        "formal": "(A21 → (¬(A19 ∨ A18) → A20))",
        "prover9": "(A21 -> (-(A19 | A18) -> A20))",
        "prover9_expression": "(found(inspector, problem) -> (-(contaminated(ingredient) | inspected(chef, ingredient)) -> discarded(ingredient)))",
        "natural": "If an inspector finds a problem, then whenever it is not the case that an ingredient is contaminated or a chef inspects an ingredient, the ingredient is discarded."
      },
      "(A21 ∨ A22)": {
        "formal": "(A21 ∨ A22)",
        "prover9": "(A21 | A22)",
        "prover9_expression": "(found(inspector, problem) | reported(staff, problem))",
        "natural": "An inspector finds a problem or staff reports a problem."
      },
      "(A22 → (¬(A19 ∨ A18) → A20))": {
        "formal": "(A22 → (¬(A19 ∨ A18) → A20))",
        "prover9": "(A22 -> (-(A19 | A18) -> A20))",
        "prover9_expression": "(reported(staff, problem) -> (-(contaminated(ingredient) | inspected(chef, ingredient)) -> discarded(ingredient)))",
        "natural": "In the event that staff reports a problem, then if it is not the case that an ingredient is contaminated or a chef inspects an ingredient, the ingredient is discarded."
      },
      "(A23 → (A4 ∨ A5))": {
        "formal": "(A23 → (A4 ∨ A5))",
        "prover9": "(A23 -> (A4 | A5))",
        "prover9_expression": "(clean(table) -> (available(table) | reserved(table)))",
        "natural": "Provided that a table is clean, then the table is available or reserved."
      },
      "(A23 → A24)": {
        "formal": "(A23 → A24)",
        "prover9": "(A23 -> A24)",
        "prover9_expression": "(clean(table) -> wiped(cleaner, table))",
        "natural": "Should a table be clean, then a cleaner wipes that table."
      },
      "(A24 → (A4 ∨ A5))": {
        "formal": "(A24 → (A4 ∨ A5))",
        "prover9": "(A24 -> (A4 | A5))",
        "prover9_expression": "(wiped(cleaner, table) -> (available(table) | reserved(table)))",
        "natural": "Under the condition that a cleaner wipes a table, then that table is available or reserved."
      },
      "(A24 → A25)": {
        "formal": "(A24 → A25)",
        "prover9": "(A24 -> A25)",
        "prover9_expression": "(wiped(cleaner, table) -> sanitized(table))",
        "natural": "Whenever a cleaner wipes a table, then the table is sanitized."
      },
      "(A25 → (A4 ∨ A5))": {
        "formal": "(A25 → (A4 ∨ A5))",
        "prover9": "(A25 -> (A4 | A5))",
        "prover9_expression": "(sanitized(table) -> (available(table) | reserved(table)))",
        "natural": "If a table is sanitized, then it is available or reserved."
      },
      "(A25 → A26)": {
        "formal": "(A25 → A26)",
        "prover9": "(A25 -> A26)",
        "prover9_expression": "(sanitized(table) -> ready(table))",
        "natural": "Provided that a table is sanitized, then it is ready."
      },
      "(A26 → (A4 ∨ A5))": {
        "formal": "(A26 → (A4 ∨ A5))",
        "prover9": "(A26 -> (A4 | A5))",
        "prover9_expression": "(ready(table) -> (available(table) | reserved(table)))",
        "natural": "Should a table be ready, then it is available or reserved."
      },
      "(A28 ∨ (¬(A26 → (A4 ∨ A5)) → A27))": {
        "formal": "(A28 ∨ (¬(A26 → (A4 ∨ A5)) → A27))",
        "prover9": "(A28 | (-(A26 -> (A4 | A5)) -> A27))",
        "prover9_expression": "(scheduled(cleaner, shift) | (-(ready(table) -> (available(table) | reserved(table))) -> dirty(table)))",
        "natural": "A cleaner is scheduled for a shift, or if it is not the case that a ready table implies it is available or reserved, then the table is dirty."
      },
      "(A29 → A28)": {
        "formal": "(A29 → A28)",
        "prover9": "(A29 -> A28)",
        "prover9_expression": "(arrived(cleaner, work) -> scheduled(cleaner, shift))",
        "natural": "In the event that a cleaner arrives at work, then the cleaner is scheduled for a shift."
      },
      "(A29 ∨ A30)": {
        "formal": "(A29 ∨ A30)",
        "prover9": "(A29 | A30)",
        "prover9_expression": "(arrived(cleaner, work) | called(manager, cleaner))",
        "natural": "Either a cleaner arrives at work or a manager calls a cleaner."
      },
      "(A3 ∨ (A2 → ¬A1))": {
        "formal": "(A3 ∨ (A2 → ¬A1))",
        "prover9": "(A3 | (A2 -> -A1))",
        "prover9_expression": "(sits(customer, table) | (pays(customer, bill) -> -orders(customer, food)))",
        "natural": "A customer sits at a table, or if a customer pays a bill, then the customer does not order a food."
      },
      "(A30 → (¬(A26 → (A4 ∨ A5)) → A27))": {
        "formal": "(A30 → (¬(A26 → (A4 ∨ A5)) → A27))",
        "prover9": "(A30 -> (-(A26 -> (A4 | A5)) -> A27))",
        "prover9_expression": "(called(manager, cleaner) -> (-(ready(table) -> (available(table) | reserved(table))) -> dirty(table)))",
        "natural": "Should a manager call a cleaner, then if it is not the case that a ready table implies it is available or reserved, the table is dirty."
      },
      "(A31 → A4)": {
        "formal": "(A31 → A4)",
        "prover9": "(A31 -> A4)",
        "prover9_expression": "(wood(table) -> available(table))",
        "natural": "Under the condition that a table is wood, then it is available."
      },
      "(A31 ∨ A32)": {
        "formal": "(A31 ∨ A32)",
        "prover9": "(A31 | A32)",
        "prover9_expression": "(wood(table) | metal(table))",
        "natural": "Either a table is wood or a table is metal."
      },
      "(A32 → A5)": {
        "formal": "(A32 → A5)",
        "prover9": "(A32 -> A5)",
        "prover9_expression": "(metal(table) -> reserved(table))",
        "natural": "Provided that a table is metal, then it is reserved."
      },
      "(A33 → A31)": {
        "formal": "(A33 → A31)",
        "prover9": "(A33 -> A31)",
        "prover9_expression": "(polished(table) -> wood(table))",
        "natural": "If a table is polished, then it is wood."
      },
      "(A33 ∨ A34)": {
        "formal": "(A33 ∨ A34)",
        "prover9": "(A33 | A34)",
        "prover9_expression": "(polished(table) | repaired(table))",
        "natural": "A table is polished or a table is repaired."
      },
      "(A34 → A32)": {
        "formal": "(A34 → A32)",
        "prover9": "(A34 -> A32)",
        "prover9_expression": "(repaired(table) -> metal(table))",
        "natural": "Whenever a table is repaired, then it is metal."
      },
      "(A35 → (A33 → A31))": {
        "formal": "(A35 → (A33 → A31))",
        "prover9": "(A35 -> (A33 -> A31))",
        "prover9_expression": "(maintained(table) -> (polished(table) -> wood(table)))",
        "natural": "In the event that a table is maintained, then if the table is polished, it is wood."
      },
      "(A35 → A37)": {
        "formal": "(A35 → A37)",
        "prover9": "(A35 -> A37)",
        "prover9_expression": "(maintained(table) -> varnished(table))",
        "natural": "Should a table be maintained, then it is varnished."
      },
      "(A35 ∨ A36)": {
        "formal": "(A35 ∨ A36)",
        "prover9": "(A35 | A36)",
        "prover9_expression": "(maintained(table) | serviced(table))",
        "natural": "Either a table is maintained or a table is serviced."
      },
      "(A36 → (A33 → A31))": {
        "formal": "(A36 → (A33 → A31))",
        "prover9": "(A36 -> (A33 -> A31))",
        "prover9_expression": "(serviced(table) -> (polished(table) -> wood(table)))",
        "natural": "Provided that a table is serviced, then if it is polished, it is wood."
      },
      "(A37 → (A33 → A31))": {
        "formal": "(A37 → (A33 → A31))",
        "prover9": "(A37 -> (A33 -> A31))",
        "prover9_expression": "(varnished(table) -> (polished(table) -> wood(table)))",
        "natural": "Under the condition that a table is varnished, then if it is polished, it is wood."
      },
      "(A37 → A38)": {
        "formal": "(A37 → A38)",
        "prover9": "(A37 -> A38)",
        "prover9_expression": "(varnished(table) -> finished(table))",
        "natural": "If a table is varnished, then it is finished."
      },
      "(A38 → (A33 → A31))": {
        "formal": "(A38 → (A33 → A31))",
        "prover9": "(A38 -> (A33 -> A31))",
        "prover9_expression": "(finished(table) -> (polished(table) -> wood(table)))",
        "natural": "Whenever a table is finished, then if it is polished, it is wood."
      },
      "(A38 → A39)": {
        "formal": "(A38 → A39)",
        "prover9": "(A38 -> A39)",
        "prover9_expression": "(finished(table) -> protected(table))",
        "natural": "Should a table be finished, then it is protected."
      },
      "(A39 → (A33 → A31))": {
        "formal": "(A39 → (A33 → A31))",
        "prover9": "(A39 -> (A33 -> A31))",
        "prover9_expression": "(protected(table) -> (polished(table) -> wood(table)))",
        "natural": "In the event that a table is protected, then if it is polished, it is wood."
      },
      "(A4 → A3)": {
        "formal": "(A4 → A3)",
        "prover9": "(A4 -> A3)",
        "prover9_expression": "(available(table) -> sits(customer, table))",
        "natural": "Provided that a table is available, then a customer sits at that table."
      },
      "(A4 ∨ A5)": {
        "formal": "(A4 ∨ A5)",
        "prover9": "(A4 | A5)",
        "prover9_expression": "(available(table) | reserved(table))",
        "natural": "Either a table is available or a table is reserved."
      },
      "(A40 → (¬(A4 ∨ A5) → ¬A6))": {
        "formal": "(A40 → (¬(A4 ∨ A5) → ¬A6))",
        "prover9": "(A40 -> (-(A4 | A5) -> -A6))",
        "prover9_expression": "(broken(chair) -> (-(available(table) | reserved(table)) -> -occupied(table)))",
        "natural": "If a chair is broken, then whenever it is not the case that a table is available or reserved, the table is not occupied."
      },
      "(A40 ∨ A41)": {
        "formal": "(A40 ∨ A41)",
        "prover9": "(A40 | A41)",
        "prover9_expression": "(broken(chair) | damaged(table))",
        "natural": "A chair is broken or a table is damaged."
      },
      "(A41 → (¬(A4 ∨ A5) → ¬A6))": {
        "formal": "(A41 → (¬(A4 ∨ A5) → ¬A6))",
        "prover9": "(A41 -> (-(A4 | A5) -> -A6))",
        "prover9_expression": "(damaged(table) -> (-(available(table) | reserved(table)) -> -occupied(table)))",
        "natural": "Under the condition that a table is damaged, then if it is not the case that a table is available or reserved, the table is not occupied."
      },
      "(A42 ∨ (A40 ∨ A41))": {
        "formal": "(A42 ∨ (A40 ∨ A41))",
        "prover9": "(A42 | (A40 | A41))",
        "prover9_expression": "(unsafe(furniture) | (broken(chair) | damaged(table)))",
        "natural": "Furniture is unsafe, or a chair is broken, or a table is damaged."
      },
      "(A43 → ¬A42)": {
        "formal": "(A43 → ¬A42)",
        "prover9": "(A43 -> -A42)",
        "prover9_expression": "(replaced(manager, furniture) -> -unsafe(furniture))",
        "natural": "Should a manager replace furniture, then it is not the case that the furniture is unsafe."
      },
      "(A44 → A43)": {
        "formal": "(A44 → A43)",
        "prover9": "(A44 -> A43)",
        "prover9_expression": "(ordered(manager, furniture) -> replaced(manager, furniture))",
        "natural": "Provided that a manager orders furniture, then the manager replaces furniture."
      },
      "(A45 → (A11 ∨ A12))": {
        "formal": "(A45 → (A11 ∨ A12))",
        "prover9": "(A45 -> (A11 | A12))",
        "prover9_expression": "(local(ingredient) -> (fresh(ingredient) | stored(ingredient)))",
        "natural": "If an ingredient is local, then it is fresh or stored."
      },
      "(A45 ∨ A46)": {
        "formal": "(A45 ∨ A46)",
        "prover9": "(A45 | A46)",
        "prover9_expression": "(local(ingredient) | imported(ingredient))",
        "natural": "Either an ingredient is local or an ingredient is imported."
      },
      "(A46 → (A11 ∨ A12))": {
        "formal": "(A46 → (A11 ∨ A12))",
        "prover9": "(A46 -> (A11 | A12))",
        "prover9_expression": "(imported(ingredient) -> (fresh(ingredient) | stored(ingredient)))",
        "natural": "Whenever an ingredient is imported, then it is fresh or stored."
      },
      "(A49 → (¬(¬(A46 → (A11 ∨ A12)) → ¬A47) → A48))": {
        "formal": "(A49 → (¬(¬(A46 → (A11 ∨ A12)) → ¬A47) → A48))",
        "prover9": "(A49 -> (-(-(A46 -> (A11 | A12)) -> -A47) -> A48))",
        "prover9_expression": "(budgeted(manager, cost) -> (-(-(imported(ingredient) -> (fresh(ingredient) | stored(ingredient))) -> -expensive(ingredient)) -> affordable(ingredient)))",
        "natural": "In the event that a manager budgets a cost, then if it is not the case that the absence of an imported ingredient implying it is fresh or stored leads to the ingredient not being expensive, the ingredient is affordable."
      },
      "(A49 ∨ A50)": {
        "formal": "(A49 ∨ A50)",
        "prover9": "(A49 | A50)",
        "prover9_expression": "(budgeted(manager, cost) | approved(owner, cost))",
        "natural": "A manager budgets a cost or an owner approves a cost."
      },
      "(A5 → (A2 → ¬A1))": {
        "formal": "(A5 → (A2 → ¬A1))",
        "prover9": "(A5 -> (A2 -> -A1))",
        "prover9_expression": "(reserved(table) -> (pays(customer, bill) -> -orders(customer, food)))",
        "natural": "Should a table be reserved, then if a customer pays a bill, the customer does not order a food."
      },
      "(A50 → (¬(¬(A46 → (A11 ∨ A12)) → ¬A47) → A48))": {
        "formal": "(A50 → (¬(¬(A46 → (A11 ∨ A12)) → ¬A47) → A48))",
        "prover9": "(A50 -> (-(-(A46 -> (A11 | A12)) -> -A47) -> A48))",
        "prover9_expression": "(approved(owner, cost) -> (-(-(imported(ingredient) -> (fresh(ingredient) | stored(ingredient))) -> -expensive(ingredient)) -> affordable(ingredient)))",
        "natural": "Under the condition that an owner approves a cost, then if it is not the case that the absence of an imported ingredient implying it is fresh or stored leads to the ingredient not being expensive, the ingredient is affordable."
      },
      "(A8 → G)": {
        "formal": "(A8 → G)",
        "prover9": "(A8 -> G)",
        "prover9_expression": "(served(food, customer) -> satisfied(customer))",
        "natural": "Provided that a food is served to a customer, then the customer is satisfied."
      },
      "(A9 → (A8 → G))": {
        "formal": "(A9 → (A8 → G))",
        "prover9": "(A9 -> (A8 -> G))",
        "prover9_expression": "(cooked(chef, food) -> (served(food, customer) -> satisfied(customer)))",
        "natural": "If a chef cooks a food, then whenever that food is served to a customer, the customer becomes satisfied."
      },
      "(A9 ∨ A10)": {
        "formal": "(A9 ∨ A10)",
        "prover9": "(A9 | A10)",
        "prover9_expression": "(cooked(chef, food) | prepared(chef, food))",
        "natural": "Either a chef cooks a food or a chef prepares a food."
      },
      "(¬(A19 ∨ A18) → A20)": {
        "formal": "(¬(A19 ∨ A18) → A20)",
        "prover9": "(-(A19 | A18) -> A20)",
        "prover9_expression": "(-(contaminated(ingredient) | inspected(chef, ingredient)) -> discarded(ingredient))",
        "natural": "Should it not be the case that an ingredient is contaminated or a chef inspects an ingredient, then the ingredient is discarded."
      },
      "(¬(A19 ∨ A18) → ¬A20)": {
        "formal": "(¬(A19 ∨ A18) → ¬A20)",
        "prover9": "(-(A19 | A18) -> -A20)",
        "prover9_expression": "(-(contaminated(ingredient) | inspected(chef, ingredient)) -> -discarded(ingredient))",
        "natural": "Provided that it is not the case that an ingredient is contaminated or a chef inspects an ingredient, then it is not the case that the ingredient is discarded."
      },
      "(¬(A26 → (A4 ∨ A5)) → A27)": {
        "formal": "(¬(A26 → (A4 ∨ A5)) → A27)",
        "prover9": "(-(A26 -> (A4 | A5)) -> A27)",
        "prover9_expression": "(-(ready(table) -> (available(table) | reserved(table))) -> dirty(table))",
        "natural": "In the event that it is not the case that a ready table implies it is available or reserved, then the table is dirty."
      },
      "(¬(A4 ∨ A5) → A6)": {
        "formal": "(¬(A4 ∨ A5) → A6)",
        "prover9": "(-(A4 | A5) -> A6)",
        "prover9_expression": "(-(available(table) | reserved(table)) -> occupied(table))",
        "natural": "Under the condition that it is not the case that a table is available or reserved, then the table is occupied."
      },
      "(¬(A4 ∨ A5) → ¬A6)": {
        "formal": "(¬(A4 ∨ A5) → ¬A6)",
        "prover9": "(-(A4 | A5) -> -A6)",
        "prover9_expression": "(-(available(table) | reserved(table)) -> -occupied(table))",
        "natural": "Should it not be the case that a table is available or reserved, then the table is not occupied."
      },
      "(¬(A46 → (A11 ∨ A12)) → A47)": {
        "formal": "(¬(A46 → (A11 ∨ A12)) → A47)",
        "prover9": "(-(A46 -> (A11 | A12)) -> A47)",
        "prover9_expression": "(-(imported(ingredient) -> (fresh(ingredient) | stored(ingredient))) -> expensive(ingredient))",
        "natural": "If it is not the case that an imported ingredient implies it is fresh or stored, then the ingredient is expensive."
      },
      "(¬(A46 → (A11 ∨ A12)) → ¬A47)": {
        "formal": "(¬(A46 → (A11 ∨ A12)) → ¬A47)",
        "prover9": "(-(A46 -> (A11 | A12)) -> -A47)",
        "prover9_expression": "(-(imported(ingredient) -> (fresh(ingredient) | stored(ingredient))) -> -expensive(ingredient))",
        "natural": "Provided that it is not the case that an imported ingredient implies it is fresh or stored, then it is not the case that the ingredient is expensive."
      },
      "(¬(¬(A4 ∨ A5) → ¬A6) → A7)": {
        "formal": "(¬(¬(A4 ∨ A5) → ¬A6) → A7)",
        "prover9": "(-(-(A4 | A5) -> -A6) -> A7)",
        "prover9_expression": "(-(-(available(table) | reserved(table)) -> -occupied(table)) -> assigned(waiter, table))",
        "natural": "Whenever it is not the case that the absence of a table being available or reserved leads to the table not being occupied, then a waiter is assigned to the table."
      },
      "(¬(¬(A4 ∨ A5) → ¬A6) → ¬A7)": {
        "formal": "(¬(¬(A4 ∨ A5) → ¬A6) → ¬A7)",
        "prover9": "(-(-(A4 | A5) -> -A6) -> -A7)",
        "prover9_expression": "(-(-(available(table) | reserved(table)) -> -occupied(table)) -> -assigned(waiter, table))",
        "natural": "Should it not be the case that the absence of a table being available or reserved leads to the table not being occupied, then it is not the case that a waiter is assigned to the table."
      },
      "(¬(¬(A46 → (A11 ∨ A12)) → ¬A47) → A48)": {
        "formal": "(¬(¬(A46 → (A11 ∨ A12)) → ¬A47) → A48)",
        "prover9": "(-(-(A46 -> (A11 | A12)) -> -A47) -> A48)",
        "prover9_expression": "(-(-(imported(ingredient) -> (fresh(ingredient) | stored(ingredient))) -> -expensive(ingredient)) -> affordable(ingredient))",
        "natural": "Under the condition that it is not the case that the absence of an imported ingredient implying it is fresh or stored leads to the ingredient not being expensive, then the ingredient is affordable."
      },
      "(¬(¬(A46 → (A11 ∨ A12)) → ¬A47) → ¬A48)": {
        "formal": "(¬(¬(A46 → (A11 ∨ A12)) → ¬A47) → ¬A48)",
        "prover9": "(-(-(A46 -> (A11 | A12)) -> -A47) -> -A48)",
        "prover9_expression": "(-(-(imported(ingredient) -> (fresh(ingredient) | stored(ingredient))) -> -expensive(ingredient)) -> -affordable(ingredient))",
        "natural": "In the event that it is not the case that the absence of an imported ingredient implying it is fresh or stored leads to the ingredient not being expensive, then it is not the case that the ingredient is affordable."
      },
      "(¬G → A1)": {
        "formal": "(¬G → A1)",
        "prover9": "(-G -> A1)",
        "prover9_expression": "(-satisfied(customer) -> orders(customer, food))",
        "natural": "Provided that a customer is not satisfied, then the customer orders a food."
      },
      "(¬G → A2)": {
        "formal": "(¬G → A2)",
        "prover9": "(-G -> A2)",
        "prover9_expression": "(-satisfied(customer) -> pays(customer, bill))",
        "natural": "Should a customer not be satisfied, then the customer pays a bill."
      },
      "(¬G → ¬A1)": {
        "formal": "(¬G → ¬A1)",
        "prover9": "(-G -> -A1)",
        "prover9_expression": "(-satisfied(customer) -> -orders(customer, food))",
        "natural": "Whenever a customer is not satisfied, then it is not the case that the customer orders a food."
      },
      "A17": {
        "formal": "A17",
        "prover9": "A17",
        "prover9_expression": "checked(manager, ingredient)",
        "natural": "A manager checks an ingredient."
      },
      "A18": {
        "formal": "A18",
        "prover9": "A18",
        "prover9_expression": "inspected(chef, ingredient)",
        "natural": "A chef inspects an ingredient."
      },
      "A23": {
        "formal": "A23",
        "prover9": "A23",
        "prover9_expression": "clean(table)",
        "natural": "A table is clean."
      },
      "A43": {
        "formal": "A43",
        "prover9": "A43",
        "prover9_expression": "replaced(manager, furniture)",
        "natural": "A manager replaces furniture."
      },
      "A44": {
        "formal": "A44",
        "prover9": "A44",
        "prover9_expression": "ordered(manager, furniture)",
        "natural": "A manager orders furniture."
      },
      "A8": {
        "formal": "A8",
        "prover9": "A8",
        "prover9_expression": "served(food, customer)",
        "natural": "A food is served to a customer."
      },
      "G": {
        "formal": "G",
        "prover9": "G",
        "prover9_expression": "satisfied(customer)",
        "natural": "A customer is satisfied."
      },
      "¬A15": {
        "formal": "¬A15",
        "prover9": "-A15",
        "prover9_expression": "-expired(ingredient)",
        "natural": "It is not the case that an ingredient is expired."
      },
      "¬A16": {
        "formal": "¬A16",
        "prover9": "-A16",
        "prover9_expression": "-spoiled(ingredient)",
        "natural": "It is not the case that an ingredient is spoiled."
      },
      "¬A19": {
        "formal": "¬A19",
        "prover9": "-A19",
        "prover9_expression": "-contaminated(ingredient)",
        "natural": "It is not the case that an ingredient is contaminated."
      },
      "¬A27": {
        "formal": "¬A27",
        "prover9": "-A27",
        "prover9_expression": "-dirty(table)",
        "natural": "It is not the case that a table is dirty."
      },
      "¬A28": {
        "formal": "¬A28",
        "prover9": "-A28",
        "prover9_expression": "-scheduled(cleaner, shift)",
        "natural": "It is not the case that a cleaner is scheduled for a shift."
      },
      "¬A3": {
        "formal": "¬A3",
        "prover9": "-A3",
        "prover9_expression": "-sits(customer, table)",
        "natural": "It is not the case that a customer sits at a table."
      },
      "¬A42": {
        "formal": "¬A42",
        "prover9": "-A42",
        "prover9_expression": "-unsafe(furniture)",
        "natural": "It is not the case that furniture is unsafe."
      }
    }
  }
}