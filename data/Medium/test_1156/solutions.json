{
  "solution_stats": {
    "total_solutions": 7,
    "details": [
      {
        "solution_id": 1,
        "steps_count": 6
      },
      {
        "solution_id": 2,
        "steps_count": 5
      },
      {
        "solution_id": 3,
        "steps_count": 11
      },
      {
        "solution_id": 4,
        "steps_count": 11
      },
      {
        "solution_id": 5,
        "steps_count": 10
      },
      {
        "solution_id": 6,
        "steps_count": 9
      },
      {
        "solution_id": 7,
        "steps_count": 7
      }
    ]
  },
  "solutions": [
    {
      "id": 1,
      "family_id": 1,
      "path_type": "core",
      "branch_from": null,
      "steps": [
        {
          "step_number": 1,
          "rule_applied": "RAA",
          "premises_used": [
            {
              "id": "Rule45",
              "prover9": "(-(-(A4 | A5) -> -A6) -> A7)",
              "prover9_expression": "(-(-(available(table) | reserved(table)) -> -occupied(table)) -> assigned(waiter, table))",
              "natural": "Whenever it is not the case that the absence of a table being available or reserved leads to the table not being occupied, then a waiter is assigned to the table."
            },
            {
              "id": "Rule46",
              "prover9": "(-(-(A4 | A5) -> -A6) -> -A7)",
              "prover9_expression": "(-(-(available(table) | reserved(table)) -> -occupied(table)) -> -assigned(waiter, table))",
              "natural": "Should it not be the case that the absence of a table being available or reserved leads to the table not being occupied, then it is not the case that a waiter is assigned to the table."
            }
          ],
          "conclusion": "(-(A4 | A5) -> -A6)",
          "natural": "Should it not be the case that a table is available or reserved, then the table is not occupied."
        },
        {
          "step_number": 2,
          "rule_applied": "RAA",
          "premises_used": [
            {
              "id": "Rule43",
              "prover9": "(-(A4 | A5) -> A6)",
              "prover9_expression": "(-(available(table) | reserved(table)) -> occupied(table))",
              "natural": "Under the condition that it is not the case that a table is available or reserved, then the table is occupied."
            },
            {
              "id": "Derived",
              "prover9": "(-(A4 | A5) -> -A6)",
              "prover9_expression": "(-(available(table) | reserved(table)) -> -occupied(table))",
              "natural": "Should it not be the case that a table is available or reserved, then the table is not occupied."
            }
          ],
          "conclusion": "(A4 | A5)",
          "natural": "Either a table is available or a table is reserved."
        },
        {
          "step_number": 3,
          "rule_applied": "CD",
          "premises_used": [
            {
              "id": "Rule29",
              "prover9": "(A4 -> A3)",
              "prover9_expression": "(available(table) -> sits(customer, table))",
              "natural": "Provided that a table is available, then a customer sits at that table."
            },
            {
              "id": "Rule39",
              "prover9": "(A5 -> (A2 -> -A1))",
              "prover9_expression": "(reserved(table) -> (pays(customer, bill) -> -orders(customer, food)))",
              "natural": "Should a table be reserved, then if a customer pays a bill, the customer does not order a food."
            },
            {
              "id": "Derived",
              "prover9": "(A4 | A5)",
              "prover9_expression": "(available(table) | reserved(table))",
              "natural": "Either a table is available or a table is reserved."
            }
          ],
          "conclusion": "(A3 | (A2 -> -A1))",
          "natural": "A customer sits at a table, or if a customer pays a bill, then the customer does not order a food."
        },
        {
          "step_number": 4,
          "rule_applied": "DS",
          "premises_used": [
            {
              "id": "Derived",
              "prover9": "(A3 | (A2 -> -A1))",
              "prover9_expression": "(sits(customer, table) | (pays(customer, bill) -> -orders(customer, food)))",
              "natural": "A customer sits at a table, or if a customer pays a bill, then the customer does not order a food."
            },
            {
              "id": "Fact8",
              "prover9": "-A3",
              "prover9_expression": "-sits(customer, table)",
              "natural": "It is not the case that a customer sits at a table."
            }
          ],
          "conclusion": "(A2 -> -A1)",
          "natural": "Whenever a customer pays a bill, then it is not the case that the customer orders a food."
        },
        {
          "step_number": 5,
          "rule_applied": "HS",
          "premises_used": [
            {
              "id": "Rule49",
              "prover9": "(-G -> A2)",
              "prover9_expression": "(-satisfied(customer) -> pays(customer, bill))",
              "natural": "Should a customer not be satisfied, then the customer pays a bill."
            },
            {
              "id": "Derived",
              "prover9": "(A2 -> -A1)",
              "prover9_expression": "(pays(customer, bill) -> -orders(customer, food))",
              "natural": "Whenever a customer pays a bill, then it is not the case that the customer orders a food."
            }
          ],
          "conclusion": "(-G -> -A1)",
          "natural": "Whenever a customer is not satisfied, then it is not the case that the customer orders a food."
        },
        {
          "step_number": 6,
          "rule_applied": "RAA",
          "premises_used": [
            {
              "id": "Rule48",
              "prover9": "(-G -> A1)",
              "prover9_expression": "(-satisfied(customer) -> orders(customer, food))",
              "natural": "Provided that a customer is not satisfied, then the customer orders a food."
            },
            {
              "id": "Derived",
              "prover9": "(-G -> -A1)",
              "prover9_expression": "(-satisfied(customer) -> -orders(customer, food))",
              "natural": "Whenever a customer is not satisfied, then it is not the case that the customer orders a food."
            }
          ],
          "conclusion": "G",
          "natural": "A customer is satisfied."
        }
      ]
    },
    {
      "id": 2,
      "family_id": 2,
      "path_type": "core",
      "branch_from": null,
      "steps": [
        {
          "step_number": 1,
          "rule_applied": "DS",
          "premises_used": [
            {
              "id": "Rule6",
              "prover9": "(A15 | (A13 | A14))",
              "prover9_expression": "(expired(ingredient) | (delivered(supplier, ingredient) | purchased(manager, ingredient)))",
              "natural": "Either an ingredient is expired, or a supplier delivers an ingredient, or a manager purchases an ingredient."
            },
            {
              "id": "Fact4",
              "prover9": "-A15",
              "prover9_expression": "-expired(ingredient)",
              "natural": "It is not the case that an ingredient is expired."
            }
          ],
          "conclusion": "(A13 | A14)",
          "natural": "A supplier delivers an ingredient or a manager purchases an ingredient."
        },
        {
          "step_number": 2,
          "rule_applied": "CD",
          "premises_used": [
            {
              "id": "Rule4",
              "prover9": "(A13 -> A11)",
              "prover9_expression": "(delivered(supplier, ingredient) -> fresh(ingredient))",
              "natural": "If a supplier delivers an ingredient, then that ingredient is fresh."
            },
            {
              "id": "Rule5",
              "prover9": "(A14 -> A12)",
              "prover9_expression": "(purchased(manager, ingredient) -> stored(ingredient))",
              "natural": "In the event that a manager purchases an ingredient, then that ingredient is stored."
            },
            {
              "id": "Derived",
              "prover9": "(A13 | A14)",
              "prover9_expression": "(delivered(supplier, ingredient) | purchased(manager, ingredient))",
              "natural": "A supplier delivers an ingredient or a manager purchases an ingredient."
            }
          ],
          "conclusion": "(A11 | A12)",
          "natural": "Either an ingredient is fresh or an ingredient is stored."
        },
        {
          "step_number": 3,
          "rule_applied": "CD",
          "premises_used": [
            {
              "id": "Rule2",
              "prover9": "(A11 -> A9)",
              "prover9_expression": "(fresh(ingredient) -> cooked(chef, food))",
              "natural": "Under the condition that an ingredient is fresh, then a chef cooks a food."
            },
            {
              "id": "Rule3",
              "prover9": "(A12 -> A10)",
              "prover9_expression": "(stored(ingredient) -> prepared(chef, food))",
              "natural": "Whenever an ingredient is stored, then a chef prepares a food."
            },
            {
              "id": "Derived",
              "prover9": "(A11 | A12)",
              "prover9_expression": "(fresh(ingredient) | stored(ingredient))",
              "natural": "Either an ingredient is fresh or an ingredient is stored."
            }
          ],
          "conclusion": "(A9 | A10)",
          "natural": "Either a chef cooks a food or a chef prepares a food."
        },
        {
          "step_number": 4,
          "rule_applied": "DE",
          "premises_used": [
            {
              "id": "Derived",
              "prover9": "(A9 | A10)",
              "prover9_expression": "(cooked(chef, food) | prepared(chef, food))",
              "natural": "Either a chef cooks a food or a chef prepares a food."
            },
            {
              "id": "Rule41",
              "prover9": "(A9 -> (A8 -> G))",
              "prover9_expression": "(cooked(chef, food) -> (served(food, customer) -> satisfied(customer)))",
              "natural": "If a chef cooks a food, then whenever that food is served to a customer, the customer becomes satisfied."
            },
            {
              "id": "Rule1",
              "prover9": "(A10 -> (A8 -> G))",
              "prover9_expression": "(prepared(chef, food) -> (served(food, customer) -> satisfied(customer)))",
              "natural": "Provided that a chef prepares a food, then if that food is served to a customer, the customer becomes satisfied."
            }
          ],
          "conclusion": "(A8 -> G)",
          "natural": "Provided that a food is served to a customer, then the customer is satisfied."
        },
        {
          "step_number": 5,
          "rule_applied": "MP",
          "premises_used": [
            {
              "id": "Derived",
              "prover9": "(A8 -> G)",
              "prover9_expression": "(served(food, customer) -> satisfied(customer))",
              "natural": "Provided that a food is served to a customer, then the customer is satisfied."
            },
            {
              "id": "Fact3",
              "prover9": "A8",
              "prover9_expression": "served(food, customer)",
              "natural": "A food is served to a customer."
            }
          ],
          "conclusion": "G",
          "natural": "A customer is satisfied."
        }
      ]
    },
    {
      "id": 3,
      "family_id": 1,
      "path_type": "branch",
      "branch_from": 0,
      "steps": [
        {
          "step_number": 1,
          "rule_applied": "DE",
          "premises_used": [
            {
              "id": "Rule11",
              "prover9": "(A21 | A22)",
              "prover9_expression": "(found(inspector, problem) | reported(staff, problem))",
              "natural": "An inspector finds a problem or staff reports a problem."
            },
            {
              "id": "Rule10",
              "prover9": "(A21 -> (-(A19 | A18) -> A20))",
              "prover9_expression": "(found(inspector, problem) -> (-(contaminated(ingredient) | inspected(chef, ingredient)) -> discarded(ingredient)))",
              "natural": "If an inspector finds a problem, then whenever it is not the case that an ingredient is contaminated or a chef inspects an ingredient, the ingredient is discarded."
            },
            {
              "id": "Rule12",
              "prover9": "(A22 -> (-(A19 | A18) -> A20))",
              "prover9_expression": "(reported(staff, problem) -> (-(contaminated(ingredient) | inspected(chef, ingredient)) -> discarded(ingredient)))",
              "natural": "In the event that staff reports a problem, then if it is not the case that an ingredient is contaminated or a chef inspects an ingredient, the ingredient is discarded."
            }
          ],
          "conclusion": "(-(A19 | A18) -> A20)",
          "natural": "Should it not be the case that an ingredient is contaminated or a chef inspects an ingredient, then the ingredient is discarded."
        },
        {
          "step_number": 2,
          "rule_applied": "RAA",
          "premises_used": [
            {
              "id": "Derived",
              "prover9": "(-(A19 | A18) -> A20)",
              "prover9_expression": "(-(contaminated(ingredient) | inspected(chef, ingredient)) -> discarded(ingredient))",
              "natural": "Should it not be the case that an ingredient is contaminated or a chef inspects an ingredient, then the ingredient is discarded."
            },
            {
              "id": "Rule42",
              "prover9": "(-(A19 | A18) -> -A20)",
              "prover9_expression": "(-(contaminated(ingredient) | inspected(chef, ingredient)) -> -discarded(ingredient))",
              "natural": "Provided that it is not the case that an ingredient is contaminated or a chef inspects an ingredient, then it is not the case that the ingredient is discarded."
            }
          ],
          "conclusion": "(A19 | A18)",
          "natural": "Either an ingredient is contaminated or a chef inspects an ingredient."
        },
        {
          "step_number": 3,
          "rule_applied": "DS",
          "premises_used": [
            {
              "id": "Derived",
              "prover9": "(A19 | A18)",
              "prover9_expression": "(contaminated(ingredient) | inspected(chef, ingredient))",
              "natural": "Either an ingredient is contaminated or a chef inspects an ingredient."
            },
            {
              "id": "Fact5",
              "prover9": "-A19",
              "prover9_expression": "-contaminated(ingredient)",
              "natural": "It is not the case that an ingredient is contaminated."
            }
          ],
          "conclusion": "A18",
          "natural": "A chef inspects an ingredient."
        },
        {
          "step_number": 4,
          "rule_applied": "MP",
          "premises_used": [
            {
              "id": "Rule9",
              "prover9": "(A18 -> A17)",
              "prover9_expression": "(inspected(chef, ingredient) -> checked(manager, ingredient))",
              "natural": "Provided that a chef inspects an ingredient, then a manager checks that ingredient."
            },
            {
              "id": "Derived",
              "prover9": "A18",
              "prover9_expression": "inspected(chef, ingredient)",
              "natural": "A chef inspects an ingredient."
            }
          ],
          "conclusion": "A17",
          "natural": "A manager checks an ingredient."
        },
        {
          "step_number": 5,
          "rule_applied": "MP",
          "premises_used": [
            {
              "id": "Rule8",
              "prover9": "(A17 -> -A16)",
              "prover9_expression": "(checked(manager, ingredient) -> -spoiled(ingredient))",
              "natural": "Should a manager check an ingredient, then it is not the case that the ingredient is spoiled."
            },
            {
              "id": "Derived",
              "prover9": "A17",
              "prover9_expression": "checked(manager, ingredient)",
              "natural": "A manager checks an ingredient."
            }
          ],
          "conclusion": "-A16",
          "natural": "It is not the case that an ingredient is spoiled."
        },
        {
          "step_number": 6,
          "rule_applied": "DS",
          "premises_used": [
            {
              "id": "Rule7",
              "prover9": "(A16 | (-(A4 | A5) -> -A6))",
              "prover9_expression": "(spoiled(ingredient) | (-(available(table) | reserved(table)) -> -occupied(table)))",
              "natural": "An ingredient is spoiled, or if it is not the case that a table is available or reserved, then the table is not occupied."
            },
            {
              "id": "Derived",
              "prover9": "-A16",
              "prover9_expression": "-spoiled(ingredient)",
              "natural": "It is not the case that an ingredient is spoiled."
            }
          ],
          "conclusion": "(-(A4 | A5) -> -A6)",
          "natural": "Should it not be the case that a table is available or reserved, then the table is not occupied."
        },
        {
          "step_number": 7,
          "rule_applied": "RAA",
          "premises_used": [
            {
              "id": "Rule43",
              "prover9": "(-(A4 | A5) -> A6)",
              "prover9_expression": "(-(available(table) | reserved(table)) -> occupied(table))",
              "natural": "Under the condition that it is not the case that a table is available or reserved, then the table is occupied."
            },
            {
              "id": "Derived",
              "prover9": "(-(A4 | A5) -> -A6)",
              "prover9_expression": "(-(available(table) | reserved(table)) -> -occupied(table))",
              "natural": "Should it not be the case that a table is available or reserved, then the table is not occupied."
            }
          ],
          "conclusion": "(A4 | A5)",
          "natural": "Either a table is available or a table is reserved."
        },
        {
          "step_number": 8,
          "rule_applied": "CD",
          "premises_used": [
            {
              "id": "Rule29",
              "prover9": "(A4 -> A3)",
              "prover9_expression": "(available(table) -> sits(customer, table))",
              "natural": "Provided that a table is available, then a customer sits at that table."
            },
            {
              "id": "Rule39",
              "prover9": "(A5 -> (A2 -> -A1))",
              "prover9_expression": "(reserved(table) -> (pays(customer, bill) -> -orders(customer, food)))",
              "natural": "Should a table be reserved, then if a customer pays a bill, the customer does not order a food."
            },
            {
              "id": "Derived",
              "prover9": "(A4 | A5)",
              "prover9_expression": "(available(table) | reserved(table))",
              "natural": "Either a table is available or a table is reserved."
            }
          ],
          "conclusion": "(A3 | (A2 -> -A1))",
          "natural": "A customer sits at a table, or if a customer pays a bill, then the customer does not order a food."
        },
        {
          "step_number": 9,
          "rule_applied": "DS",
          "premises_used": [
            {
              "id": "Derived",
              "prover9": "(A3 | (A2 -> -A1))",
              "prover9_expression": "(sits(customer, table) | (pays(customer, bill) -> -orders(customer, food)))",
              "natural": "A customer sits at a table, or if a customer pays a bill, then the customer does not order a food."
            },
            {
              "id": "Fact8",
              "prover9": "-A3",
              "prover9_expression": "-sits(customer, table)",
              "natural": "It is not the case that a customer sits at a table."
            }
          ],
          "conclusion": "(A2 -> -A1)",
          "natural": "Whenever a customer pays a bill, then it is not the case that the customer orders a food."
        },
        {
          "step_number": 10,
          "rule_applied": "HS",
          "premises_used": [
            {
              "id": "Rule49",
              "prover9": "(-G -> A2)",
              "prover9_expression": "(-satisfied(customer) -> pays(customer, bill))",
              "natural": "Should a customer not be satisfied, then the customer pays a bill."
            },
            {
              "id": "Derived",
              "prover9": "(A2 -> -A1)",
              "prover9_expression": "(pays(customer, bill) -> -orders(customer, food))",
              "natural": "Whenever a customer pays a bill, then it is not the case that the customer orders a food."
            }
          ],
          "conclusion": "(-G -> -A1)",
          "natural": "Whenever a customer is not satisfied, then it is not the case that the customer orders a food."
        },
        {
          "step_number": 11,
          "rule_applied": "RAA",
          "premises_used": [
            {
              "id": "Rule48",
              "prover9": "(-G -> A1)",
              "prover9_expression": "(-satisfied(customer) -> orders(customer, food))",
              "natural": "Provided that a customer is not satisfied, then the customer orders a food."
            },
            {
              "id": "Derived",
              "prover9": "(-G -> -A1)",
              "prover9_expression": "(-satisfied(customer) -> -orders(customer, food))",
              "natural": "Whenever a customer is not satisfied, then it is not the case that the customer orders a food."
            }
          ],
          "conclusion": "G",
          "natural": "A customer is satisfied."
        }
      ]
    },
    {
      "id": 4,
      "family_id": 1,
      "path_type": "branch",
      "branch_from": 1,
      "steps": [
        {
          "step_number": 1,
          "rule_applied": "CD",
          "premises_used": [
            {
              "id": "Rule16",
              "prover9": "(A29 -> A28)",
              "prover9_expression": "(arrived(cleaner, work) -> scheduled(cleaner, shift))",
              "natural": "In the event that a cleaner arrives at work, then the cleaner is scheduled for a shift."
            },
            {
              "id": "Rule18",
              "prover9": "(A30 -> (-(A26 -> (A4 | A5)) -> A27))",
              "prover9_expression": "(called(manager, cleaner) -> (-(ready(table) -> (available(table) | reserved(table))) -> dirty(table)))",
              "natural": "Should a manager call a cleaner, then if it is not the case that a ready table implies it is available or reserved, the table is dirty."
            },
            {
              "id": "Rule17",
              "prover9": "(A29 | A30)",
              "prover9_expression": "(arrived(cleaner, work) | called(manager, cleaner))",
              "natural": "Either a cleaner arrives at work or a manager calls a cleaner."
            }
          ],
          "conclusion": "(A28 | (-(A26 -> (A4 | A5)) -> A27))",
          "natural": "A cleaner is scheduled for a shift, or if it is not the case that a ready table implies it is available or reserved, then the table is dirty."
        },
        {
          "step_number": 2,
          "rule_applied": "DS",
          "premises_used": [
            {
              "id": "Derived",
              "prover9": "(A28 | (-(A26 -> (A4 | A5)) -> A27))",
              "prover9_expression": "(scheduled(cleaner, shift) | (-(ready(table) -> (available(table) | reserved(table))) -> dirty(table)))",
              "natural": "A cleaner is scheduled for a shift, or if it is not the case that a ready table implies it is available or reserved, then the table is dirty."
            },
            {
              "id": "Fact7",
              "prover9": "-A28",
              "prover9_expression": "-scheduled(cleaner, shift)",
              "natural": "It is not the case that a cleaner is scheduled for a shift."
            }
          ],
          "conclusion": "(-(A26 -> (A4 | A5)) -> A27)",
          "natural": "In the event that it is not the case that a ready table implies it is available or reserved, then the table is dirty."
        },
        {
          "step_number": 3,
          "rule_applied": "MT",
          "premises_used": [
            {
              "id": "Derived",
              "prover9": "(-(A26 -> (A4 | A5)) -> A27)",
              "prover9_expression": "(-(ready(table) -> (available(table) | reserved(table))) -> dirty(table))",
              "natural": "In the event that it is not the case that a ready table implies it is available or reserved, then the table is dirty."
            },
            {
              "id": "Fact6",
              "prover9": "-A27",
              "prover9_expression": "-dirty(table)",
              "natural": "It is not the case that a table is dirty."
            }
          ],
          "conclusion": "(A26 -> (A4 | A5))",
          "natural": "Should a table be ready, then it is available or reserved."
        },
        {
          "step_number": 4,
          "rule_applied": "HS",
          "premises_used": [
            {
              "id": "Rule15",
              "prover9": "(A25 -> A26)",
              "prover9_expression": "(sanitized(table) -> ready(table))",
              "natural": "Provided that a table is sanitized, then it is ready."
            },
            {
              "id": "Derived",
              "prover9": "(A26 -> (A4 | A5))",
              "prover9_expression": "(ready(table) -> (available(table) | reserved(table)))",
              "natural": "Should a table be ready, then it is available or reserved."
            }
          ],
          "conclusion": "(A25 -> (A4 | A5))",
          "natural": "If a table is sanitized, then it is available or reserved."
        },
        {
          "step_number": 5,
          "rule_applied": "HS",
          "premises_used": [
            {
              "id": "Rule14",
              "prover9": "(A24 -> A25)",
              "prover9_expression": "(wiped(cleaner, table) -> sanitized(table))",
              "natural": "Whenever a cleaner wipes a table, then the table is sanitized."
            },
            {
              "id": "Derived",
              "prover9": "(A25 -> (A4 | A5))",
              "prover9_expression": "(sanitized(table) -> (available(table) | reserved(table)))",
              "natural": "If a table is sanitized, then it is available or reserved."
            }
          ],
          "conclusion": "(A24 -> (A4 | A5))",
          "natural": "Under the condition that a cleaner wipes a table, then that table is available or reserved."
        },
        {
          "step_number": 6,
          "rule_applied": "HS",
          "premises_used": [
            {
              "id": "Rule13",
              "prover9": "(A23 -> A24)",
              "prover9_expression": "(clean(table) -> wiped(cleaner, table))",
              "natural": "Should a table be clean, then a cleaner wipes that table."
            },
            {
              "id": "Derived",
              "prover9": "(A24 -> (A4 | A5))",
              "prover9_expression": "(wiped(cleaner, table) -> (available(table) | reserved(table)))",
              "natural": "Under the condition that a cleaner wipes a table, then that table is available or reserved."
            }
          ],
          "conclusion": "(A23 -> (A4 | A5))",
          "natural": "Provided that a table is clean, then the table is available or reserved."
        },
        {
          "step_number": 7,
          "rule_applied": "MP",
          "premises_used": [
            {
              "id": "Derived",
              "prover9": "(A23 -> (A4 | A5))",
              "prover9_expression": "(clean(table) -> (available(table) | reserved(table)))",
              "natural": "Provided that a table is clean, then the table is available or reserved."
            },
            {
              "id": "Fact1",
              "prover9": "A23",
              "prover9_expression": "clean(table)",
              "natural": "A table is clean."
            }
          ],
          "conclusion": "(A4 | A5)",
          "natural": "Either a table is available or a table is reserved."
        },
        {
          "step_number": 8,
          "rule_applied": "CD",
          "premises_used": [
            {
              "id": "Rule29",
              "prover9": "(A4 -> A3)",
              "prover9_expression": "(available(table) -> sits(customer, table))",
              "natural": "Provided that a table is available, then a customer sits at that table."
            },
            {
              "id": "Rule39",
              "prover9": "(A5 -> (A2 -> -A1))",
              "prover9_expression": "(reserved(table) -> (pays(customer, bill) -> -orders(customer, food)))",
              "natural": "Should a table be reserved, then if a customer pays a bill, the customer does not order a food."
            },
            {
              "id": "Derived",
              "prover9": "(A4 | A5)",
              "prover9_expression": "(available(table) | reserved(table))",
              "natural": "Either a table is available or a table is reserved."
            }
          ],
          "conclusion": "(A3 | (A2 -> -A1))",
          "natural": "A customer sits at a table, or if a customer pays a bill, then the customer does not order a food."
        },
        {
          "step_number": 9,
          "rule_applied": "DS",
          "premises_used": [
            {
              "id": "Derived",
              "prover9": "(A3 | (A2 -> -A1))",
              "prover9_expression": "(sits(customer, table) | (pays(customer, bill) -> -orders(customer, food)))",
              "natural": "A customer sits at a table, or if a customer pays a bill, then the customer does not order a food."
            },
            {
              "id": "Fact8",
              "prover9": "-A3",
              "prover9_expression": "-sits(customer, table)",
              "natural": "It is not the case that a customer sits at a table."
            }
          ],
          "conclusion": "(A2 -> -A1)",
          "natural": "Whenever a customer pays a bill, then it is not the case that the customer orders a food."
        },
        {
          "step_number": 10,
          "rule_applied": "HS",
          "premises_used": [
            {
              "id": "Rule49",
              "prover9": "(-G -> A2)",
              "prover9_expression": "(-satisfied(customer) -> pays(customer, bill))",
              "natural": "Should a customer not be satisfied, then the customer pays a bill."
            },
            {
              "id": "Derived",
              "prover9": "(A2 -> -A1)",
              "prover9_expression": "(pays(customer, bill) -> -orders(customer, food))",
              "natural": "Whenever a customer pays a bill, then it is not the case that the customer orders a food."
            }
          ],
          "conclusion": "(-G -> -A1)",
          "natural": "Whenever a customer is not satisfied, then it is not the case that the customer orders a food."
        },
        {
          "step_number": 11,
          "rule_applied": "RAA",
          "premises_used": [
            {
              "id": "Rule48",
              "prover9": "(-G -> A1)",
              "prover9_expression": "(-satisfied(customer) -> orders(customer, food))",
              "natural": "Provided that a customer is not satisfied, then the customer orders a food."
            },
            {
              "id": "Derived",
              "prover9": "(-G -> -A1)",
              "prover9_expression": "(-satisfied(customer) -> -orders(customer, food))",
              "natural": "Whenever a customer is not satisfied, then it is not the case that the customer orders a food."
            }
          ],
          "conclusion": "G",
          "natural": "A customer is satisfied."
        }
      ]
    },
    {
      "id": 5,
      "family_id": 1,
      "path_type": "branch",
      "branch_from": 1,
      "steps": [
        {
          "step_number": 1,
          "rule_applied": "HS",
          "premises_used": [
            {
              "id": "Rule27",
              "prover9": "(A38 -> A39)",
              "prover9_expression": "(finished(table) -> protected(table))",
              "natural": "Should a table be finished, then it is protected."
            },
            {
              "id": "Rule28",
              "prover9": "(A39 -> (A33 -> A31))",
              "prover9_expression": "(protected(table) -> (polished(table) -> wood(table)))",
              "natural": "In the event that a table is protected, then if it is polished, it is wood."
            }
          ],
          "conclusion": "(A38 -> (A33 -> A31))",
          "natural": "Whenever a table is finished, then if it is polished, it is wood."
        },
        {
          "step_number": 2,
          "rule_applied": "HS",
          "premises_used": [
            {
              "id": "Rule26",
              "prover9": "(A37 -> A38)",
              "prover9_expression": "(varnished(table) -> finished(table))",
              "natural": "If a table is varnished, then it is finished."
            },
            {
              "id": "Derived",
              "prover9": "(A38 -> (A33 -> A31))",
              "prover9_expression": "(finished(table) -> (polished(table) -> wood(table)))",
              "natural": "Whenever a table is finished, then if it is polished, it is wood."
            }
          ],
          "conclusion": "(A37 -> (A33 -> A31))",
          "natural": "Under the condition that a table is varnished, then if it is polished, it is wood."
        },
        {
          "step_number": 3,
          "rule_applied": "HS",
          "premises_used": [
            {
              "id": "Rule23",
              "prover9": "(A35 -> A37)",
              "prover9_expression": "(maintained(table) -> varnished(table))",
              "natural": "Should a table be maintained, then it is varnished."
            },
            {
              "id": "Derived",
              "prover9": "(A37 -> (A33 -> A31))",
              "prover9_expression": "(varnished(table) -> (polished(table) -> wood(table)))",
              "natural": "Under the condition that a table is varnished, then if it is polished, it is wood."
            }
          ],
          "conclusion": "(A35 -> (A33 -> A31))",
          "natural": "In the event that a table is maintained, then if the table is polished, it is wood."
        },
        {
          "step_number": 4,
          "rule_applied": "DE",
          "premises_used": [
            {
              "id": "Rule24",
              "prover9": "(A35 | A36)",
              "prover9_expression": "(maintained(table) | serviced(table))",
              "natural": "Either a table is maintained or a table is serviced."
            },
            {
              "id": "Derived",
              "prover9": "(A35 -> (A33 -> A31))",
              "prover9_expression": "(maintained(table) -> (polished(table) -> wood(table)))",
              "natural": "In the event that a table is maintained, then if the table is polished, it is wood."
            },
            {
              "id": "Rule25",
              "prover9": "(A36 -> (A33 -> A31))",
              "prover9_expression": "(serviced(table) -> (polished(table) -> wood(table)))",
              "natural": "Provided that a table is serviced, then if it is polished, it is wood."
            }
          ],
          "conclusion": "(A33 -> A31)",
          "natural": "If a table is polished, then it is wood."
        },
        {
          "step_number": 5,
          "rule_applied": "CD",
          "premises_used": [
            {
              "id": "Derived",
              "prover9": "(A33 -> A31)",
              "prover9_expression": "(polished(table) -> wood(table))",
              "natural": "If a table is polished, then it is wood."
            },
            {
              "id": "Rule22",
              "prover9": "(A34 -> A32)",
              "prover9_expression": "(repaired(table) -> metal(table))",
              "natural": "Whenever a table is repaired, then it is metal."
            },
            {
              "id": "Rule21",
              "prover9": "(A33 | A34)",
              "prover9_expression": "(polished(table) | repaired(table))",
              "natural": "A table is polished or a table is repaired."
            }
          ],
          "conclusion": "(A31 | A32)",
          "natural": "Either a table is wood or a table is metal."
        },
        {
          "step_number": 6,
          "rule_applied": "CD",
          "premises_used": [
            {
              "id": "Rule19",
              "prover9": "(A31 -> A4)",
              "prover9_expression": "(wood(table) -> available(table))",
              "natural": "Under the condition that a table is wood, then it is available."
            },
            {
              "id": "Rule20",
              "prover9": "(A32 -> A5)",
              "prover9_expression": "(metal(table) -> reserved(table))",
              "natural": "Provided that a table is metal, then it is reserved."
            },
            {
              "id": "Derived",
              "prover9": "(A31 | A32)",
              "prover9_expression": "(wood(table) | metal(table))",
              "natural": "Either a table is wood or a table is metal."
            }
          ],
          "conclusion": "(A4 | A5)",
          "natural": "Either a table is available or a table is reserved."
        },
        {
          "step_number": 7,
          "rule_applied": "CD",
          "premises_used": [
            {
              "id": "Rule29",
              "prover9": "(A4 -> A3)",
              "prover9_expression": "(available(table) -> sits(customer, table))",
              "natural": "Provided that a table is available, then a customer sits at that table."
            },
            {
              "id": "Rule39",
              "prover9": "(A5 -> (A2 -> -A1))",
              "prover9_expression": "(reserved(table) -> (pays(customer, bill) -> -orders(customer, food)))",
              "natural": "Should a table be reserved, then if a customer pays a bill, the customer does not order a food."
            },
            {
              "id": "Derived",
              "prover9": "(A4 | A5)",
              "prover9_expression": "(available(table) | reserved(table))",
              "natural": "Either a table is available or a table is reserved."
            }
          ],
          "conclusion": "(A3 | (A2 -> -A1))",
          "natural": "A customer sits at a table, or if a customer pays a bill, then the customer does not order a food."
        },
        {
          "step_number": 8,
          "rule_applied": "DS",
          "premises_used": [
            {
              "id": "Derived",
              "prover9": "(A3 | (A2 -> -A1))",
              "prover9_expression": "(sits(customer, table) | (pays(customer, bill) -> -orders(customer, food)))",
              "natural": "A customer sits at a table, or if a customer pays a bill, then the customer does not order a food."
            },
            {
              "id": "Fact8",
              "prover9": "-A3",
              "prover9_expression": "-sits(customer, table)",
              "natural": "It is not the case that a customer sits at a table."
            }
          ],
          "conclusion": "(A2 -> -A1)",
          "natural": "Whenever a customer pays a bill, then it is not the case that the customer orders a food."
        },
        {
          "step_number": 9,
          "rule_applied": "HS",
          "premises_used": [
            {
              "id": "Rule49",
              "prover9": "(-G -> A2)",
              "prover9_expression": "(-satisfied(customer) -> pays(customer, bill))",
              "natural": "Should a customer not be satisfied, then the customer pays a bill."
            },
            {
              "id": "Derived",
              "prover9": "(A2 -> -A1)",
              "prover9_expression": "(pays(customer, bill) -> -orders(customer, food))",
              "natural": "Whenever a customer pays a bill, then it is not the case that the customer orders a food."
            }
          ],
          "conclusion": "(-G -> -A1)",
          "natural": "Whenever a customer is not satisfied, then it is not the case that the customer orders a food."
        },
        {
          "step_number": 10,
          "rule_applied": "RAA",
          "premises_used": [
            {
              "id": "Rule48",
              "prover9": "(-G -> A1)",
              "prover9_expression": "(-satisfied(customer) -> orders(customer, food))",
              "natural": "Provided that a customer is not satisfied, then the customer orders a food."
            },
            {
              "id": "Derived",
              "prover9": "(-G -> -A1)",
              "prover9_expression": "(-satisfied(customer) -> -orders(customer, food))",
              "natural": "Whenever a customer is not satisfied, then it is not the case that the customer orders a food."
            }
          ],
          "conclusion": "G",
          "natural": "A customer is satisfied."
        }
      ]
    },
    {
      "id": 6,
      "family_id": 1,
      "path_type": "branch",
      "branch_from": 0,
      "steps": [
        {
          "step_number": 1,
          "rule_applied": "MP",
          "premises_used": [
            {
              "id": "Rule34",
              "prover9": "(A44 -> A43)",
              "prover9_expression": "(ordered(manager, furniture) -> replaced(manager, furniture))",
              "natural": "Provided that a manager orders furniture, then the manager replaces furniture."
            },
            {
              "id": "Fact2",
              "prover9": "A44",
              "prover9_expression": "ordered(manager, furniture)",
              "natural": "A manager orders furniture."
            }
          ],
          "conclusion": "A43",
          "natural": "A manager replaces furniture."
        },
        {
          "step_number": 2,
          "rule_applied": "MP",
          "premises_used": [
            {
              "id": "Rule33",
              "prover9": "(A43 -> -A42)",
              "prover9_expression": "(replaced(manager, furniture) -> -unsafe(furniture))",
              "natural": "Should a manager replace furniture, then it is not the case that the furniture is unsafe."
            },
            {
              "id": "Derived",
              "prover9": "A43",
              "prover9_expression": "replaced(manager, furniture)",
              "natural": "A manager replaces furniture."
            }
          ],
          "conclusion": "-A42",
          "natural": "It is not the case that furniture is unsafe."
        },
        {
          "step_number": 3,
          "rule_applied": "DS",
          "premises_used": [
            {
              "id": "Rule32",
              "prover9": "(A42 | (A40 | A41))",
              "prover9_expression": "(unsafe(furniture) | (broken(chair) | damaged(table)))",
              "natural": "Furniture is unsafe, or a chair is broken, or a table is damaged."
            },
            {
              "id": "Derived",
              "prover9": "-A42",
              "prover9_expression": "-unsafe(furniture)",
              "natural": "It is not the case that furniture is unsafe."
            }
          ],
          "conclusion": "(A40 | A41)",
          "natural": "A chair is broken or a table is damaged."
        },
        {
          "step_number": 4,
          "rule_applied": "DE",
          "premises_used": [
            {
              "id": "Derived",
              "prover9": "(A40 | A41)",
              "prover9_expression": "(broken(chair) | damaged(table))",
              "natural": "A chair is broken or a table is damaged."
            },
            {
              "id": "Rule30",
              "prover9": "(A40 -> (-(A4 | A5) -> -A6))",
              "prover9_expression": "(broken(chair) -> (-(available(table) | reserved(table)) -> -occupied(table)))",
              "natural": "If a chair is broken, then whenever it is not the case that a table is available or reserved, the table is not occupied."
            },
            {
              "id": "Rule31",
              "prover9": "(A41 -> (-(A4 | A5) -> -A6))",
              "prover9_expression": "(damaged(table) -> (-(available(table) | reserved(table)) -> -occupied(table)))",
              "natural": "Under the condition that a table is damaged, then if it is not the case that a table is available or reserved, the table is not occupied."
            }
          ],
          "conclusion": "(-(A4 | A5) -> -A6)",
          "natural": "Should it not be the case that a table is available or reserved, then the table is not occupied."
        },
        {
          "step_number": 5,
          "rule_applied": "RAA",
          "premises_used": [
            {
              "id": "Rule43",
              "prover9": "(-(A4 | A5) -> A6)",
              "prover9_expression": "(-(available(table) | reserved(table)) -> occupied(table))",
              "natural": "Under the condition that it is not the case that a table is available or reserved, then the table is occupied."
            },
            {
              "id": "Derived",
              "prover9": "(-(A4 | A5) -> -A6)",
              "prover9_expression": "(-(available(table) | reserved(table)) -> -occupied(table))",
              "natural": "Should it not be the case that a table is available or reserved, then the table is not occupied."
            }
          ],
          "conclusion": "(A4 | A5)",
          "natural": "Either a table is available or a table is reserved."
        },
        {
          "step_number": 6,
          "rule_applied": "CD",
          "premises_used": [
            {
              "id": "Rule29",
              "prover9": "(A4 -> A3)",
              "prover9_expression": "(available(table) -> sits(customer, table))",
              "natural": "Provided that a table is available, then a customer sits at that table."
            },
            {
              "id": "Rule39",
              "prover9": "(A5 -> (A2 -> -A1))",
              "prover9_expression": "(reserved(table) -> (pays(customer, bill) -> -orders(customer, food)))",
              "natural": "Should a table be reserved, then if a customer pays a bill, the customer does not order a food."
            },
            {
              "id": "Derived",
              "prover9": "(A4 | A5)",
              "prover9_expression": "(available(table) | reserved(table))",
              "natural": "Either a table is available or a table is reserved."
            }
          ],
          "conclusion": "(A3 | (A2 -> -A1))",
          "natural": "A customer sits at a table, or if a customer pays a bill, then the customer does not order a food."
        },
        {
          "step_number": 7,
          "rule_applied": "DS",
          "premises_used": [
            {
              "id": "Derived",
              "prover9": "(A3 | (A2 -> -A1))",
              "prover9_expression": "(sits(customer, table) | (pays(customer, bill) -> -orders(customer, food)))",
              "natural": "A customer sits at a table, or if a customer pays a bill, then the customer does not order a food."
            },
            {
              "id": "Fact8",
              "prover9": "-A3",
              "prover9_expression": "-sits(customer, table)",
              "natural": "It is not the case that a customer sits at a table."
            }
          ],
          "conclusion": "(A2 -> -A1)",
          "natural": "Whenever a customer pays a bill, then it is not the case that the customer orders a food."
        },
        {
          "step_number": 8,
          "rule_applied": "HS",
          "premises_used": [
            {
              "id": "Rule49",
              "prover9": "(-G -> A2)",
              "prover9_expression": "(-satisfied(customer) -> pays(customer, bill))",
              "natural": "Should a customer not be satisfied, then the customer pays a bill."
            },
            {
              "id": "Derived",
              "prover9": "(A2 -> -A1)",
              "prover9_expression": "(pays(customer, bill) -> -orders(customer, food))",
              "natural": "Whenever a customer pays a bill, then it is not the case that the customer orders a food."
            }
          ],
          "conclusion": "(-G -> -A1)",
          "natural": "Whenever a customer is not satisfied, then it is not the case that the customer orders a food."
        },
        {
          "step_number": 9,
          "rule_applied": "RAA",
          "premises_used": [
            {
              "id": "Rule48",
              "prover9": "(-G -> A1)",
              "prover9_expression": "(-satisfied(customer) -> orders(customer, food))",
              "natural": "Provided that a customer is not satisfied, then the customer orders a food."
            },
            {
              "id": "Derived",
              "prover9": "(-G -> -A1)",
              "prover9_expression": "(-satisfied(customer) -> -orders(customer, food))",
              "natural": "Whenever a customer is not satisfied, then it is not the case that the customer orders a food."
            }
          ],
          "conclusion": "G",
          "natural": "A customer is satisfied."
        }
      ]
    },
    {
      "id": 7,
      "family_id": 2,
      "path_type": "branch",
      "branch_from": 1,
      "steps": [
        {
          "step_number": 1,
          "rule_applied": "DE",
          "premises_used": [
            {
              "id": "Rule38",
              "prover9": "(A49 | A50)",
              "prover9_expression": "(budgeted(manager, cost) | approved(owner, cost))",
              "natural": "A manager budgets a cost or an owner approves a cost."
            },
            {
              "id": "Rule37",
              "prover9": "(A49 -> (-(-(A46 -> (A11 | A12)) -> -A47) -> A48))",
              "prover9_expression": "(budgeted(manager, cost) -> (-(-(imported(ingredient) -> (fresh(ingredient) | stored(ingredient))) -> -expensive(ingredient)) -> affordable(ingredient)))",
              "natural": "In the event that a manager budgets a cost, then if it is not the case that the absence of an imported ingredient implying it is fresh or stored leads to the ingredient not being expensive, the ingredient is affordable."
            },
            {
              "id": "Rule40",
              "prover9": "(A50 -> (-(-(A46 -> (A11 | A12)) -> -A47) -> A48))",
              "prover9_expression": "(approved(owner, cost) -> (-(-(imported(ingredient) -> (fresh(ingredient) | stored(ingredient))) -> -expensive(ingredient)) -> affordable(ingredient)))",
              "natural": "Under the condition that an owner approves a cost, then if it is not the case that the absence of an imported ingredient implying it is fresh or stored leads to the ingredient not being expensive, the ingredient is affordable."
            }
          ],
          "conclusion": "(-(-(A46 -> (A11 | A12)) -> -A47) -> A48)",
          "natural": "Under the condition that it is not the case that the absence of an imported ingredient implying it is fresh or stored leads to the ingredient not being expensive, then the ingredient is affordable."
        },
        {
          "step_number": 2,
          "rule_applied": "RAA",
          "premises_used": [
            {
              "id": "Derived",
              "prover9": "(-(-(A46 -> (A11 | A12)) -> -A47) -> A48)",
              "prover9_expression": "(-(-(imported(ingredient) -> (fresh(ingredient) | stored(ingredient))) -> -expensive(ingredient)) -> affordable(ingredient))",
              "natural": "Under the condition that it is not the case that the absence of an imported ingredient implying it is fresh or stored leads to the ingredient not being expensive, then the ingredient is affordable."
            },
            {
              "id": "Rule47",
              "prover9": "(-(-(A46 -> (A11 | A12)) -> -A47) -> -A48)",
              "prover9_expression": "(-(-(imported(ingredient) -> (fresh(ingredient) | stored(ingredient))) -> -expensive(ingredient)) -> -affordable(ingredient))",
              "natural": "In the event that it is not the case that the absence of an imported ingredient implying it is fresh or stored leads to the ingredient not being expensive, then it is not the case that the ingredient is affordable."
            }
          ],
          "conclusion": "(-(A46 -> (A11 | A12)) -> -A47)",
          "natural": "Provided that it is not the case that an imported ingredient implies it is fresh or stored, then it is not the case that the ingredient is expensive."
        },
        {
          "step_number": 3,
          "rule_applied": "RAA",
          "premises_used": [
            {
              "id": "Rule44",
              "prover9": "(-(A46 -> (A11 | A12)) -> A47)",
              "prover9_expression": "(-(imported(ingredient) -> (fresh(ingredient) | stored(ingredient))) -> expensive(ingredient))",
              "natural": "If it is not the case that an imported ingredient implies it is fresh or stored, then the ingredient is expensive."
            },
            {
              "id": "Derived",
              "prover9": "(-(A46 -> (A11 | A12)) -> -A47)",
              "prover9_expression": "(-(imported(ingredient) -> (fresh(ingredient) | stored(ingredient))) -> -expensive(ingredient))",
              "natural": "Provided that it is not the case that an imported ingredient implies it is fresh or stored, then it is not the case that the ingredient is expensive."
            }
          ],
          "conclusion": "(A46 -> (A11 | A12))",
          "natural": "Whenever an ingredient is imported, then it is fresh or stored."
        },
        {
          "step_number": 4,
          "rule_applied": "DE",
          "premises_used": [
            {
              "id": "Rule36",
              "prover9": "(A45 | A46)",
              "prover9_expression": "(local(ingredient) | imported(ingredient))",
              "natural": "Either an ingredient is local or an ingredient is imported."
            },
            {
              "id": "Rule35",
              "prover9": "(A45 -> (A11 | A12))",
              "prover9_expression": "(local(ingredient) -> (fresh(ingredient) | stored(ingredient)))",
              "natural": "If an ingredient is local, then it is fresh or stored."
            },
            {
              "id": "Derived",
              "prover9": "(A46 -> (A11 | A12))",
              "prover9_expression": "(imported(ingredient) -> (fresh(ingredient) | stored(ingredient)))",
              "natural": "Whenever an ingredient is imported, then it is fresh or stored."
            }
          ],
          "conclusion": "(A11 | A12)",
          "natural": "Either an ingredient is fresh or an ingredient is stored."
        },
        {
          "step_number": 5,
          "rule_applied": "CD",
          "premises_used": [
            {
              "id": "Rule2",
              "prover9": "(A11 -> A9)",
              "prover9_expression": "(fresh(ingredient) -> cooked(chef, food))",
              "natural": "Under the condition that an ingredient is fresh, then a chef cooks a food."
            },
            {
              "id": "Rule3",
              "prover9": "(A12 -> A10)",
              "prover9_expression": "(stored(ingredient) -> prepared(chef, food))",
              "natural": "Whenever an ingredient is stored, then a chef prepares a food."
            },
            {
              "id": "Derived",
              "prover9": "(A11 | A12)",
              "prover9_expression": "(fresh(ingredient) | stored(ingredient))",
              "natural": "Either an ingredient is fresh or an ingredient is stored."
            }
          ],
          "conclusion": "(A9 | A10)",
          "natural": "Either a chef cooks a food or a chef prepares a food."
        },
        {
          "step_number": 6,
          "rule_applied": "DE",
          "premises_used": [
            {
              "id": "Derived",
              "prover9": "(A9 | A10)",
              "prover9_expression": "(cooked(chef, food) | prepared(chef, food))",
              "natural": "Either a chef cooks a food or a chef prepares a food."
            },
            {
              "id": "Rule41",
              "prover9": "(A9 -> (A8 -> G))",
              "prover9_expression": "(cooked(chef, food) -> (served(food, customer) -> satisfied(customer)))",
              "natural": "If a chef cooks a food, then whenever that food is served to a customer, the customer becomes satisfied."
            },
            {
              "id": "Rule1",
              "prover9": "(A10 -> (A8 -> G))",
              "prover9_expression": "(prepared(chef, food) -> (served(food, customer) -> satisfied(customer)))",
              "natural": "Provided that a chef prepares a food, then if that food is served to a customer, the customer becomes satisfied."
            }
          ],
          "conclusion": "(A8 -> G)",
          "natural": "Provided that a food is served to a customer, then the customer is satisfied."
        },
        {
          "step_number": 7,
          "rule_applied": "MP",
          "premises_used": [
            {
              "id": "Derived",
              "prover9": "(A8 -> G)",
              "prover9_expression": "(served(food, customer) -> satisfied(customer))",
              "natural": "Provided that a food is served to a customer, then the customer is satisfied."
            },
            {
              "id": "Fact3",
              "prover9": "A8",
              "prover9_expression": "served(food, customer)",
              "natural": "A food is served to a customer."
            }
          ],
          "conclusion": "G",
          "natural": "A customer is satisfied."
        }
      ]
    }
  ]
}