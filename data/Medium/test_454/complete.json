{
  "metadata": {
    "graph_path": "./logic_graph.png",
    "num_solutions": 5,
    "family_stats": {
      "1": {
        "core": 1,
        "branch": 0
      },
      "2": {
        "core": 1,
        "branch": 3
      }
    }
  },
  "knowledge_base": {
    "rules": [
      {
        "id": "Rule1",
        "formal": "(A1 ∨ A2)",
        "prover9_expression": "(vehicle_available(drone1, station1) | vehicle_available(robocar1, station1))",
        "natural": "Either drone1 is available at station1 or robocar1 is available at station1."
      },
      {
        "id": "Rule2",
        "formal": "(A11 → A12)",
        "prover9_expression": "(loading_error(package1, drone1) -> loading_complete(package1, drone1))",
        "natural": "Whenever there is a loading error for package1 on drone1, loading of package1 on drone1 is complete."
      },
      {
        "id": "Rule3",
        "formal": "(A11 → ¬A12)",
        "prover9_expression": "(loading_error(package1, drone1) -> -loading_complete(package1, drone1))",
        "natural": "If there is a loading error for package1 on drone1, then it is not the case that loading of package1 on drone1 is complete."
      },
      {
        "id": "Rule4",
        "formal": "(A13 → ¬A9)",
        "prover9_expression": "(route_clear(route1) -> -package_loaded(package1, drone1))",
        "natural": "Under the condition that route1 is clear, package1 is not loaded on drone1."
      },
      {
        "id": "Rule5",
        "formal": "(A14 ∨ A13)",
        "prover9_expression": "(route_blocked(route1) | route_clear(route1))",
        "natural": "Route1 is blocked or route1 is clear."
      },
      {
        "id": "Rule6",
        "formal": "(A15 → ¬A14)",
        "prover9_expression": "(alternative_route_available(route2) -> -route_blocked(route1))",
        "natural": "Provided that alternative route2 is available, route1 is not blocked."
      },
      {
        "id": "Rule7",
        "formal": "(A15 ∨ A16)",
        "prover9_expression": "(alternative_route_available(route2) | alternative_route_available(route3))",
        "natural": "Alternative route2 is available or alternative route3 is available."
      },
      {
        "id": "Rule8",
        "formal": "(A17 → (A16 → ¬A14))",
        "prover9_expression": "(weather_clear(area1) -> (alternative_route_available(route3) -> -route_blocked(route1)))",
        "natural": "If weather in area1 is clear, then whenever alternative route3 is available, route1 is not blocked."
      },
      {
        "id": "Rule9",
        "formal": "(A18 → A17)",
        "prover9_expression": "(weather_monitored(area1) -> weather_clear(area1))",
        "natural": "Under the condition that weather in area1 is monitored, weather in area1 is clear."
      },
      {
        "id": "Rule10",
        "formal": "(A19 → A18)",
        "prover9_expression": "(weather_system_functional(monitor1) -> weather_monitored(area1))",
        "natural": "Provided that weather system monitor1 is functional, weather in area1 is monitored."
      },
      {
        "id": "Rule11",
        "formal": "(A2 → G)",
        "prover9_expression": "(vehicle_available(robocar1, station1) -> delivery_successful(package1))",
        "natural": "If robocar1 is available at station1, then delivery of package1 is successful."
      },
      {
        "id": "Rule12",
        "formal": "(A25 ∨ ¬A24)",
        "prover9_expression": "(delivery_failed(package1) | -delivery_completed(package1))",
        "natural": "Either delivery of package1 has failed or delivery of package1 is not completed."
      },
      {
        "id": "Rule13",
        "formal": "(A26 → ¬A25)",
        "prover9_expression": "(vehicle_recovered(drone1) -> -delivery_failed(package1))",
        "natural": "Provided that drone1 has been recovered, delivery of package1 has not failed."
      },
      {
        "id": "Rule14",
        "formal": "(A27 → ¬A25)",
        "prover9_expression": "(vehicle_lost(drone1) -> -delivery_failed(package1))",
        "natural": "Under the condition that drone1 is lost, delivery of package1 has not failed."
      },
      {
        "id": "Rule15",
        "formal": "(A29 → ¬A28)",
        "prover9_expression": "(recovery_canceled(drone1) -> -recovery_initiated(drone1))",
        "natural": "If recovery of drone1 has been canceled, then recovery of drone1 has not been initiated."
      },
      {
        "id": "Rule16",
        "formal": "(A3 → (A1 → G))",
        "prover9_expression": "(command_center_functional(center1) -> (vehicle_available(drone1, station1) -> delivery_successful(package1)))",
        "natural": "Whenever command center1 is functional, then if drone1 is available at station1, delivery of package1 is successful."
      },
      {
        "id": "Rule17",
        "formal": "(A32 → (A31 → (A30 → ¬A10)))",
        "prover9_expression": "(damage_detected(package1) -> (damage_protocol_enabled(drone1) -> (package_damaged(package1) -> -package_secured(package1, drone1))))",
        "natural": "Under the condition that damage to package1 has been detected, then if damage protocol is enabled for drone1, then if package1 is damaged, package1 is not secured on drone1."
      },
      {
        "id": "Rule18",
        "formal": "(A33 → (A31 → (A30 → ¬A10)))",
        "prover9_expression": "(damage_undetected(package1) -> (damage_protocol_enabled(drone1) -> (package_damaged(package1) -> -package_secured(package1, drone1))))",
        "natural": "Provided that damage to package1 is undetected, then if damage protocol is enabled for drone1, then if package1 is damaged, package1 is not secured on drone1."
      },
      {
        "id": "Rule19",
        "formal": "(A34 → (A32 ∨ A33))",
        "prover9_expression": "(inspection_scheduled(package1) -> (damage_detected(package1) | damage_undetected(package1)))",
        "natural": "If inspection of package1 is scheduled, then either damage to package1 has been detected or damage to package1 is undetected."
      },
      {
        "id": "Rule20",
        "formal": "(A34 ∨ A35)",
        "prover9_expression": "(inspection_scheduled(package1) | inspection_bypassed(package1))",
        "natural": "Inspection of package1 is scheduled or inspection of package1 is bypassed."
      },
      {
        "id": "Rule21",
        "formal": "(A35 → (A32 ∨ A33))",
        "prover9_expression": "(inspection_bypassed(package1) -> (damage_detected(package1) | damage_undetected(package1)))",
        "natural": "Provided that inspection of package1 is bypassed, then either damage to package1 has been detected or damage to package1 is undetected."
      },
      {
        "id": "Rule22",
        "formal": "(A5 → ¬A4)",
        "prover9_expression": "(device_online(charger1) -> -delivery_delayed(package1))",
        "natural": "Whenever charger1 is online, delivery of package1 is not delayed."
      },
      {
        "id": "Rule23",
        "formal": "(A6 → ¬A4)",
        "prover9_expression": "(device_online(backup_charger1) -> -delivery_delayed(package1))",
        "natural": "Under the condition that backup charger1 is online, delivery of package1 is not delayed."
      },
      {
        "id": "Rule24",
        "formal": "(A8 → (A7 → (A5 ∨ A6)))",
        "prover9_expression": "(platform_monitored(dispatch_system1) -> (platform_operational(dispatch_system1) -> (device_online(charger1) | device_online(backup_charger1))))",
        "natural": "Provided that dispatch system1 is monitored, then if dispatch system1 is operational, then either charger1 is online or backup charger1 is online."
      },
      {
        "id": "Rule25",
        "formal": "(A9 → A10)",
        "prover9_expression": "(package_loaded(package1, drone1) -> package_secured(package1, drone1))",
        "natural": "Whenever package1 is loaded on drone1, package1 is secured on drone1."
      },
      {
        "id": "Rule26",
        "formal": "(A9 → A30)",
        "prover9_expression": "(package_loaded(package1, drone1) -> package_damaged(package1))",
        "natural": "If package1 is loaded on drone1, then package1 is damaged."
      },
      {
        "id": "Rule27",
        "formal": "(A9 ∨ G)",
        "prover9_expression": "(package_loaded(package1, drone1) | delivery_successful(package1))",
        "natural": "Package1 is loaded on drone1 or delivery of package1 is successful."
      },
      {
        "id": "Rule28",
        "formal": "(¬(A21 → (A9 → ¬A10)) → A22)",
        "prover9_expression": "(-(loading_protocol_enforced(drone1) -> (package_loaded(package1, drone1) -> -package_secured(package1, drone1))) -> loading_protocol_override(drone1))",
        "natural": "Whenever it is not the case that if loading protocol is enforced for drone1 then if package1 is loaded on drone1, package1 is not secured on drone1, then loading protocol is overridden for drone1."
      },
      {
        "id": "Rule29",
        "formal": "(¬(A26 ∨ A27) → A28)",
        "prover9_expression": "(-(vehicle_recovered(drone1) | vehicle_lost(drone1)) -> recovery_initiated(drone1))",
        "natural": "Provided that it is not the case that drone1 has been recovered or drone1 is lost, then recovery of drone1 has been initiated."
      },
      {
        "id": "Rule30",
        "formal": "(¬(A26 ∨ A27) → A29)",
        "prover9_expression": "(-(vehicle_recovered(drone1) | vehicle_lost(drone1)) -> recovery_canceled(drone1))",
        "natural": "If it is not the case that drone1 has been recovered or drone1 is lost, then recovery of drone1 has been canceled."
      },
      {
        "id": "Rule31",
        "formal": "(¬(A9 → ¬A10) → A11)",
        "prover9_expression": "(-(package_loaded(package1, drone1) -> -package_secured(package1, drone1)) -> loading_error(package1, drone1))",
        "natural": "Whenever it is not the case that if package1 is loaded on drone1, then package1 is not secured on drone1, then there is a loading error for package1 on drone1."
      },
      {
        "id": "Rule32",
        "formal": "(¬(¬(A21 → (A9 → ¬A10)) → ¬A22) → ¬A23)",
        "prover9_expression": "(-(-(loading_protocol_enforced(drone1) -> (package_loaded(package1, drone1) -> -package_secured(package1, drone1))) -> -loading_protocol_override(drone1)) -> -loading_protocol_locked(drone1))",
        "natural": "If it is not the case that if it is not the case that if loading protocol is enforced for drone1 then if package1 is loaded on drone1, package1 is not secured on drone1, then loading protocol is not overridden for drone1, then loading protocol is not locked for drone1."
      },
      {
        "id": "Rule33",
        "formal": "(¬(¬(¬(A21 → (A9 → ¬A10)) → ¬A22) → A23) → A24)",
        "prover9_expression": "(-(-(-(loading_protocol_enforced(drone1) -> (package_loaded(package1, drone1) -> -package_secured(package1, drone1))) -> -loading_protocol_override(drone1)) -> loading_protocol_locked(drone1)) -> delivery_completed(package1))",
        "natural": "Under the condition that it is not the case that if it is not the case that if it is not the case that if loading protocol is enforced for drone1 then if package1 is loaded on drone1, package1 is not secured on drone1, then loading protocol is not overridden for drone1, then loading protocol is locked for drone1, then delivery of package1 is completed."
      },
      {
        "id": "Rule34",
        "formal": "(¬A19 → A20)",
        "prover9_expression": "(-weather_system_functional(monitor1) -> weather_system_malfunction(monitor1))",
        "natural": "Whenever weather system monitor1 is not functional, weather system monitor1 has malfunctioned."
      },
      {
        "id": "Rule35",
        "formal": "(¬A19 → ¬A20)",
        "prover9_expression": "(-weather_system_functional(monitor1) -> -weather_system_malfunction(monitor1))",
        "natural": "Provided that weather system monitor1 is not functional, weather system monitor1 has not malfunctioned."
      },
      {
        "id": "Rule36",
        "formal": "(¬A3 → A4)",
        "prover9_expression": "(-command_center_functional(center1) -> delivery_delayed(package1))",
        "natural": "If command center1 is not functional, then delivery of package1 is delayed."
      }
    ],
    "facts": [
      {
        "id": "Fact1",
        "formal": "A21",
        "prover9_expression": "loading_protocol_enforced(drone1)",
        "natural": "Loading protocol is enforced for drone1."
      },
      {
        "id": "Fact2",
        "formal": "A31",
        "prover9_expression": "damage_protocol_enabled(drone1)",
        "natural": "Damage protocol is enabled for drone1."
      },
      {
        "id": "Fact3",
        "formal": "A7",
        "prover9_expression": "platform_operational(dispatch_system1)",
        "natural": "Dispatch system1 is operational."
      },
      {
        "id": "Fact4",
        "formal": "A8",
        "prover9_expression": "platform_monitored(dispatch_system1)",
        "natural": "Dispatch system1 is monitored."
      }
    ]
  },
  "target": {
    "formal": "G",
    "prover9": "G",
    "prover9_expression": "delivery_successful(package1)",
    "natural": "Delivery of package1 is successful."
  },
  "solutions": [
    {
      "id": 1,
      "family_id": 1,
      "path_type": "core",
      "branch_from": null,
      "steps": [
        {
          "step_number": 1,
          "rule_applied": "MP",
          "premises_used": [
            "(A8 -> (A7 -> (A5 | A6)))",
            "A8"
          ],
          "conclusion": "(A7 -> (A5 | A6))",
          "natural": "If dispatch system1 is operational, then either charger1 is online or backup charger1 is online."
        },
        {
          "step_number": 2,
          "rule_applied": "MP",
          "premises_used": [
            "(A7 -> (A5 | A6))",
            "A7"
          ],
          "conclusion": "(A5 | A6)",
          "natural": "Either charger1 is online or backup charger1 is online."
        },
        {
          "step_number": 3,
          "rule_applied": "DE",
          "premises_used": [
            "(A5 | A6)",
            "(A5 -> -A4)",
            "(A6 -> -A4)"
          ],
          "conclusion": "-A4",
          "natural": "Delivery of package1 is not delayed."
        },
        {
          "step_number": 4,
          "rule_applied": "MT",
          "premises_used": [
            "(-A3 -> A4)",
            "-A4"
          ],
          "conclusion": "A3",
          "natural": "Command center1 is functional."
        },
        {
          "step_number": 5,
          "rule_applied": "MP",
          "premises_used": [
            "(A3 -> (A1 -> G))",
            "A3"
          ],
          "conclusion": "(A1 -> G)",
          "natural": "Provided that drone1 is available at station1, delivery of package1 is successful."
        },
        {
          "step_number": 6,
          "rule_applied": "DE",
          "premises_used": [
            "(A1 | A2)",
            "(A1 -> G)",
            "(A2 -> G)"
          ],
          "conclusion": "G",
          "natural": "Delivery of package1 is successful."
        }
      ]
    },
    {
      "id": 2,
      "family_id": 2,
      "path_type": "core",
      "branch_from": null,
      "steps": [
        {
          "step_number": 1,
          "rule_applied": "RAA",
          "premises_used": [
            "(A11 -> A12)",
            "(A11 -> -A12)"
          ],
          "conclusion": "-A11",
          "natural": "There is no loading error for package1 on drone1."
        },
        {
          "step_number": 2,
          "rule_applied": "MT",
          "premises_used": [
            "(-(A9 -> -A10) -> A11)",
            "-A11"
          ],
          "conclusion": "(A9 -> -A10)",
          "natural": "Provided that package1 is loaded on drone1, package1 is not secured on drone1."
        },
        {
          "step_number": 3,
          "rule_applied": "RAA",
          "premises_used": [
            "(A9 -> A10)",
            "(A9 -> -A10)"
          ],
          "conclusion": "-A9",
          "natural": "Package1 is not loaded on drone1."
        },
        {
          "step_number": 4,
          "rule_applied": "DS",
          "premises_used": [
            "(A9 | G)",
            "-A9"
          ],
          "conclusion": "G",
          "natural": "Delivery of package1 is successful."
        }
      ]
    },
    {
      "id": 3,
      "family_id": 2,
      "path_type": "branch",
      "branch_from": 2,
      "steps": [
        {
          "step_number": 1,
          "rule_applied": "RAA",
          "premises_used": [
            "(-A19 -> A20)",
            "(-A19 -> -A20)"
          ],
          "conclusion": "A19",
          "natural": "Weather system monitor1 is functional."
        },
        {
          "step_number": 2,
          "rule_applied": "MP",
          "premises_used": [
            "(A19 -> A18)",
            "A19"
          ],
          "conclusion": "A18",
          "natural": "Weather in area1 is monitored."
        },
        {
          "step_number": 3,
          "rule_applied": "MP",
          "premises_used": [
            "(A18 -> A17)",
            "A18"
          ],
          "conclusion": "A17",
          "natural": "Weather in area1 is clear."
        },
        {
          "step_number": 4,
          "rule_applied": "MP",
          "premises_used": [
            "(A17 -> (A16 -> -A14))",
            "A17"
          ],
          "conclusion": "(A16 -> -A14)",
          "natural": "Whenever alternative route3 is available, route1 is not blocked."
        },
        {
          "step_number": 5,
          "rule_applied": "DE",
          "premises_used": [
            "(A15 | A16)",
            "(A15 -> -A14)",
            "(A16 -> -A14)"
          ],
          "conclusion": "-A14",
          "natural": "Route1 is not blocked."
        },
        {
          "step_number": 6,
          "rule_applied": "DS",
          "premises_used": [
            "(A14 | A13)",
            "-A14"
          ],
          "conclusion": "A13",
          "natural": "Route1 is clear."
        },
        {
          "step_number": 7,
          "rule_applied": "MP",
          "premises_used": [
            "(A13 -> -A9)",
            "A13"
          ],
          "conclusion": "-A9",
          "natural": "Package1 is not loaded on drone1."
        },
        {
          "step_number": 8,
          "rule_applied": "DS",
          "premises_used": [
            "(A9 | G)",
            "-A9"
          ],
          "conclusion": "G",
          "natural": "Delivery of package1 is successful."
        }
      ]
    },
    {
      "id": 4,
      "family_id": 2,
      "path_type": "branch",
      "branch_from": 1,
      "steps": [
        {
          "step_number": 1,
          "rule_applied": "HS",
          "premises_used": [
            "(-(A26 | A27) -> A29)",
            "(A29 -> -A28)"
          ],
          "conclusion": "(-(A26 | A27) -> -A28)",
          "natural": "Under the condition that it is not the case that drone1 has been recovered or drone1 is lost, then recovery of drone1 has not been initiated."
        },
        {
          "step_number": 2,
          "rule_applied": "RAA",
          "premises_used": [
            "(-(A26 | A27) -> A28)",
            "(-(A26 | A27) -> -A28)"
          ],
          "conclusion": "(A26 | A27)",
          "natural": "Drone1 has been recovered or drone1 is lost."
        },
        {
          "step_number": 3,
          "rule_applied": "DE",
          "premises_used": [
            "(A26 | A27)",
            "(A26 -> -A25)",
            "(A27 -> -A25)"
          ],
          "conclusion": "-A25",
          "natural": "Delivery of package1 has not failed."
        },
        {
          "step_number": 4,
          "rule_applied": "DS",
          "premises_used": [
            "(A25 | -A24)",
            "-A25"
          ],
          "conclusion": "-A24",
          "natural": "Delivery of package1 is not completed."
        },
        {
          "step_number": 5,
          "rule_applied": "MT",
          "premises_used": [
            "(-(-(-(A21 -> (A9 -> -A10)) -> -A22) -> A23) -> A24)",
            "-A24"
          ],
          "conclusion": "(-(-(A21 -> (A9 -> -A10)) -> -A22) -> A23)",
          "natural": "Provided that it is not the case that if it is not the case that if loading protocol is enforced for drone1 then if package1 is loaded on drone1, package1 is not secured on drone1, then loading protocol is not overridden for drone1, then loading protocol is locked for drone1."
        },
        {
          "step_number": 6,
          "rule_applied": "RAA",
          "premises_used": [
            "(-(-(A21 -> (A9 -> -A10)) -> -A22) -> A23)",
            "(-(-(A21 -> (A9 -> -A10)) -> -A22) -> -A23)"
          ],
          "conclusion": "(-(A21 -> (A9 -> -A10)) -> -A22)",
          "natural": "If it is not the case that if loading protocol is enforced for drone1 then if package1 is loaded on drone1, package1 is not secured on drone1, then loading protocol is not overridden for drone1."
        },
        {
          "step_number": 7,
          "rule_applied": "RAA",
          "premises_used": [
            "(-(A21 -> (A9 -> -A10)) -> A22)",
            "(-(A21 -> (A9 -> -A10)) -> -A22)"
          ],
          "conclusion": "(A21 -> (A9 -> -A10))",
          "natural": "Whenever loading protocol is enforced for drone1, then if package1 is loaded on drone1, package1 is not secured on drone1."
        },
        {
          "step_number": 8,
          "rule_applied": "MP",
          "premises_used": [
            "(A21 -> (A9 -> -A10))",
            "A21"
          ],
          "conclusion": "(A9 -> -A10)",
          "natural": "Provided that package1 is loaded on drone1, package1 is not secured on drone1."
        },
        {
          "step_number": 9,
          "rule_applied": "RAA",
          "premises_used": [
            "(A9 -> A10)",
            "(A9 -> -A10)"
          ],
          "conclusion": "-A9",
          "natural": "Package1 is not loaded on drone1."
        },
        {
          "step_number": 10,
          "rule_applied": "DS",
          "premises_used": [
            "(A9 | G)",
            "-A9"
          ],
          "conclusion": "G",
          "natural": "Delivery of package1 is successful."
        }
      ]
    },
    {
      "id": 5,
      "family_id": 2,
      "path_type": "branch",
      "branch_from": 1,
      "steps": [
        {
          "step_number": 1,
          "rule_applied": "DE",
          "premises_used": [
            "(A34 | A35)",
            "(A34 -> (A32 | A33))",
            "(A35 -> (A32 | A33))"
          ],
          "conclusion": "(A32 | A33)",
          "natural": "Damage to package1 has been detected or damage to package1 is undetected."
        },
        {
          "step_number": 2,
          "rule_applied": "DE",
          "premises_used": [
            "(A32 | A33)",
            "(A32 -> (A31 -> (A30 -> -A10)))",
            "(A33 -> (A31 -> (A30 -> -A10)))"
          ],
          "conclusion": "(A31 -> (A30 -> -A10))",
          "natural": "If damage protocol is enabled for drone1, then if package1 is damaged, package1 is not secured on drone1."
        },
        {
          "step_number": 3,
          "rule_applied": "MP",
          "premises_used": [
            "(A31 -> (A30 -> -A10))",
            "A31"
          ],
          "conclusion": "(A30 -> -A10)",
          "natural": "Provided that package1 is damaged, package1 is not secured on drone1."
        },
        {
          "step_number": 4,
          "rule_applied": "HS",
          "premises_used": [
            "(A9 -> A30)",
            "(A30 -> -A10)"
          ],
          "conclusion": "(A9 -> -A10)",
          "natural": "Provided that package1 is loaded on drone1, package1 is not secured on drone1."
        },
        {
          "step_number": 5,
          "rule_applied": "RAA",
          "premises_used": [
            "(A9 -> A10)",
            "(A9 -> -A10)"
          ],
          "conclusion": "-A9",
          "natural": "Package1 is not loaded on drone1."
        },
        {
          "step_number": 6,
          "rule_applied": "DS",
          "premises_used": [
            "(A9 | G)",
            "-A9"
          ],
          "conclusion": "G",
          "natural": "Delivery of package1 is successful."
        }
      ]
    }
  ],
  "translations": {
    "domain_theme": "Autonomous Delivery System",
    "atomic_facts": {
      "A1": "vehicle_available(drone1, station1)",
      "A2": "vehicle_available(robocar1, station1)",
      "A3": "command_center_functional(center1)",
      "A4": "delivery_delayed(package1)",
      "A5": "device_online(charger1)",
      "A6": "device_online(backup_charger1)",
      "A7": "platform_operational(dispatch_system1)",
      "A8": "platform_monitored(dispatch_system1)",
      "A9": "package_loaded(package1, drone1)",
      "A10": "package_secured(package1, drone1)",
      "A11": "loading_error(package1, drone1)",
      "A12": "loading_complete(package1, drone1)",
      "A13": "route_clear(route1)",
      "A14": "route_blocked(route1)",
      "A15": "alternative_route_available(route2)",
      "A16": "alternative_route_available(route3)",
      "A17": "weather_clear(area1)",
      "A18": "weather_monitored(area1)",
      "A19": "weather_system_functional(monitor1)",
      "A20": "weather_system_malfunction(monitor1)",
      "A21": "loading_protocol_enforced(drone1)",
      "A22": "loading_protocol_override(drone1)",
      "A23": "loading_protocol_locked(drone1)",
      "A24": "delivery_completed(package1)",
      "A25": "delivery_failed(package1)",
      "A26": "vehicle_recovered(drone1)",
      "A27": "vehicle_lost(drone1)",
      "A28": "recovery_initiated(drone1)",
      "A29": "recovery_canceled(drone1)",
      "A30": "package_damaged(package1)",
      "A31": "damage_protocol_enabled(drone1)",
      "A32": "damage_detected(package1)",
      "A33": "damage_undetected(package1)",
      "A34": "inspection_scheduled(package1)",
      "A35": "inspection_bypassed(package1)",
      "G": "delivery_successful(package1)"
    },
    "natural_facts": {
      "A1": "Drone1 is available at station1.",
      "A2": "Robocar1 is available at station1.",
      "A3": "Command center1 is functional.",
      "A4": "Delivery of package1 is delayed.",
      "A5": "Charger1 is online.",
      "A6": "Backup charger1 is online.",
      "A7": "Dispatch system1 is operational.",
      "A8": "Dispatch system1 is monitored.",
      "A9": "Package1 is loaded on drone1.",
      "A10": "Package1 is secured on drone1.",
      "A11": "There is a loading error for package1 on drone1.",
      "A12": "Loading of package1 on drone1 is complete.",
      "A13": "Route1 is clear.",
      "A14": "Route1 is blocked.",
      "A15": "Alternative route2 is available.",
      "A16": "Alternative route3 is available.",
      "A17": "Weather in area1 is clear.",
      "A18": "Weather in area1 is monitored.",
      "A19": "Weather system monitor1 is functional.",
      "A20": "Weather system monitor1 has malfunctioned.",
      "A21": "Loading protocol is enforced for drone1.",
      "A22": "Loading protocol is overridden for drone1.",
      "A23": "Loading protocol is locked for drone1.",
      "A24": "Delivery of package1 is completed.",
      "A25": "Delivery of package1 has failed.",
      "A26": "Drone1 has been recovered.",
      "A27": "Drone1 is lost.",
      "A28": "Recovery of drone1 has been initiated.",
      "A29": "Recovery of drone1 has been canceled.",
      "A30": "Package1 is damaged.",
      "A31": "Damage protocol is enabled for drone1.",
      "A32": "Damage to package1 has been detected.",
      "A33": "Damage to package1 is undetected.",
      "A34": "Inspection of package1 is scheduled.",
      "A35": "Inspection of package1 is bypassed.",
      "G": "Delivery of package1 is successful."
    },
    "prover9_expressions": [
      "(vehicle_available(drone1, station1) -> delivery_successful(package1))",
      "(vehicle_available(drone1, station1) | vehicle_available(robocar1, station1))",
      "(loading_error(package1, drone1) -> loading_complete(package1, drone1))",
      "(loading_error(package1, drone1) -> -loading_complete(package1, drone1))",
      "(route_clear(route1) -> -package_loaded(package1, drone1))",
      "(route_blocked(route1) | route_clear(route1))",
      "(alternative_route_available(route2) -> -route_blocked(route1))",
      "(alternative_route_available(route2) | alternative_route_available(route3))",
      "(alternative_route_available(route3) -> -route_blocked(route1))",
      "(weather_clear(area1) -> (alternative_route_available(route3) -> -route_blocked(route1)))",
      "(weather_monitored(area1) -> weather_clear(area1))",
      "(weather_system_functional(monitor1) -> weather_monitored(area1))",
      "(vehicle_available(robocar1, station1) -> delivery_successful(package1))",
      "(loading_protocol_enforced(drone1) -> (package_loaded(package1, drone1) -> -package_secured(package1, drone1)))",
      "(delivery_failed(package1) | -delivery_completed(package1))",
      "(vehicle_recovered(drone1) -> -delivery_failed(package1))",
      "(vehicle_recovered(drone1) | vehicle_lost(drone1))",
      "(vehicle_lost(drone1) -> -delivery_failed(package1))",
      "(recovery_canceled(drone1) -> -recovery_initiated(drone1))",
      "(command_center_functional(center1) -> (vehicle_available(drone1, station1) -> delivery_successful(package1)))",
      "(package_damaged(package1) -> -package_secured(package1, drone1))",
      "(damage_protocol_enabled(drone1) -> (package_damaged(package1) -> -package_secured(package1, drone1)))",
      "(damage_detected(package1) -> (damage_protocol_enabled(drone1) -> (package_damaged(package1) -> -package_secured(package1, drone1))))",
      "(damage_detected(package1) | damage_undetected(package1))",
      "(damage_undetected(package1) -> (damage_protocol_enabled(drone1) -> (package_damaged(package1) -> -package_secured(package1, drone1))))",
      "(inspection_scheduled(package1) -> (damage_detected(package1) | damage_undetected(package1)))",
      "(inspection_scheduled(package1) | inspection_bypassed(package1))",
      "(inspection_bypassed(package1) -> (damage_detected(package1) | damage_undetected(package1)))",
      "(device_online(charger1) -> -delivery_delayed(package1))",
      "(device_online(charger1) | device_online(backup_charger1))",
      "(device_online(backup_charger1) -> -delivery_delayed(package1))",
      "(platform_operational(dispatch_system1) -> (device_online(charger1) | device_online(backup_charger1)))",
      "(platform_monitored(dispatch_system1) -> (platform_operational(dispatch_system1) -> (device_online(charger1) | device_online(backup_charger1))))",
      "(package_loaded(package1, drone1) -> package_secured(package1, drone1))",
      "(package_loaded(package1, drone1) -> package_damaged(package1))",
      "(package_loaded(package1, drone1) -> -package_secured(package1, drone1))",
      "(package_loaded(package1, drone1) | delivery_successful(package1))",
      "(-(loading_protocol_enforced(drone1) -> (package_loaded(package1, drone1) -> -package_secured(package1, drone1))) -> loading_protocol_override(drone1))",
      "(-(loading_protocol_enforced(drone1) -> (package_loaded(package1, drone1) -> -package_secured(package1, drone1))) -> -loading_protocol_override(drone1))",
      "(-(vehicle_recovered(drone1) | vehicle_lost(drone1)) -> recovery_initiated(drone1))",
      "(-(vehicle_recovered(drone1) | vehicle_lost(drone1)) -> recovery_canceled(drone1))",
      "(-(vehicle_recovered(drone1) | vehicle_lost(drone1)) -> -recovery_initiated(drone1))",
      "(-(package_loaded(package1, drone1) -> -package_secured(package1, drone1)) -> loading_error(package1, drone1))",
      "(-(-(loading_protocol_enforced(drone1) -> (package_loaded(package1, drone1) -> -package_secured(package1, drone1))) -> -loading_protocol_override(drone1)) -> loading_protocol_locked(drone1))",
      "(-(-(loading_protocol_enforced(drone1) -> (package_loaded(package1, drone1) -> -package_secured(package1, drone1))) -> -loading_protocol_override(drone1)) -> -loading_protocol_locked(drone1))",
      "(-(-(-(loading_protocol_enforced(drone1) -> (package_loaded(package1, drone1) -> -package_secured(package1, drone1))) -> -loading_protocol_override(drone1)) -> loading_protocol_locked(drone1)) -> delivery_completed(package1))",
      "(-weather_system_functional(monitor1) -> weather_system_malfunction(monitor1))",
      "(-weather_system_functional(monitor1) -> -weather_system_malfunction(monitor1))",
      "(-command_center_functional(center1) -> delivery_delayed(package1))",
      "route_clear(route1)",
      "weather_clear(area1)",
      "weather_monitored(area1)",
      "weather_system_functional(monitor1)",
      "loading_protocol_enforced(drone1)",
      "command_center_functional(center1)",
      "damage_protocol_enabled(drone1)",
      "platform_operational(dispatch_system1)",
      "platform_monitored(dispatch_system1)",
      "delivery_successful(package1)",
      "-loading_error(package1, drone1)",
      "-route_blocked(route1)",
      "-delivery_completed(package1)",
      "-delivery_failed(package1)",
      "-delivery_delayed(package1)",
      "-package_loaded(package1, drone1)"
    ],
    "natural_expressions": [
      "Provided that drone1 is available at station1, delivery of package1 is successful.",
      "Either drone1 is available at station1 or robocar1 is available at station1.",
      "Whenever there is a loading error for package1 on drone1, loading of package1 on drone1 is complete.",
      "If there is a loading error for package1 on drone1, then it is not the case that loading of package1 on drone1 is complete.",
      "Under the condition that route1 is clear, package1 is not loaded on drone1.",
      "Route1 is blocked or route1 is clear.",
      "Provided that alternative route2 is available, route1 is not blocked.",
      "Alternative route2 is available or alternative route3 is available.",
      "Whenever alternative route3 is available, route1 is not blocked.",
      "If weather in area1 is clear, then whenever alternative route3 is available, route1 is not blocked.",
      "Under the condition that weather in area1 is monitored, weather in area1 is clear.",
      "Provided that weather system monitor1 is functional, weather in area1 is monitored.",
      "If robocar1 is available at station1, then delivery of package1 is successful.",
      "Whenever loading protocol is enforced for drone1, then if package1 is loaded on drone1, package1 is not secured on drone1.",
      "Either delivery of package1 has failed or delivery of package1 is not completed.",
      "Provided that drone1 has been recovered, delivery of package1 has not failed.",
      "Drone1 has been recovered or drone1 is lost.",
      "Under the condition that drone1 is lost, delivery of package1 has not failed.",
      "If recovery of drone1 has been canceled, then recovery of drone1 has not been initiated.",
      "Whenever command center1 is functional, then if drone1 is available at station1, delivery of package1 is successful.",
      "Provided that package1 is damaged, package1 is not secured on drone1.",
      "If damage protocol is enabled for drone1, then if package1 is damaged, package1 is not secured on drone1.",
      "Under the condition that damage to package1 has been detected, then if damage protocol is enabled for drone1, then if package1 is damaged, package1 is not secured on drone1.",
      "Damage to package1 has been detected or damage to package1 is undetected.",
      "Provided that damage to package1 is undetected, then if damage protocol is enabled for drone1, then if package1 is damaged, package1 is not secured on drone1.",
      "If inspection of package1 is scheduled, then either damage to package1 has been detected or damage to package1 is undetected.",
      "Inspection of package1 is scheduled or inspection of package1 is bypassed.",
      "Provided that inspection of package1 is bypassed, then either damage to package1 has been detected or damage to package1 is undetected.",
      "Whenever charger1 is online, delivery of package1 is not delayed.",
      "Either charger1 is online or backup charger1 is online.",
      "Under the condition that backup charger1 is online, delivery of package1 is not delayed.",
      "If dispatch system1 is operational, then either charger1 is online or backup charger1 is online.",
      "Provided that dispatch system1 is monitored, then if dispatch system1 is operational, then either charger1 is online or backup charger1 is online.",
      "Whenever package1 is loaded on drone1, package1 is secured on drone1.",
      "If package1 is loaded on drone1, then package1 is damaged.",
      "Provided that package1 is loaded on drone1, package1 is not secured on drone1.",
      "Package1 is loaded on drone1 or delivery of package1 is successful.",
      "Whenever it is not the case that if loading protocol is enforced for drone1 then if package1 is loaded on drone1, package1 is not secured on drone1, then loading protocol is overridden for drone1.",
      "If it is not the case that if loading protocol is enforced for drone1 then if package1 is loaded on drone1, package1 is not secured on drone1, then loading protocol is not overridden for drone1.",
      "Provided that it is not the case that drone1 has been recovered or drone1 is lost, then recovery of drone1 has been initiated.",
      "If it is not the case that drone1 has been recovered or drone1 is lost, then recovery of drone1 has been canceled.",
      "Under the condition that it is not the case that drone1 has been recovered or drone1 is lost, then recovery of drone1 has not been initiated.",
      "Whenever it is not the case that if package1 is loaded on drone1, then package1 is not secured on drone1, then there is a loading error for package1 on drone1.",
      "Provided that it is not the case that if it is not the case that if loading protocol is enforced for drone1 then if package1 is loaded on drone1, package1 is not secured on drone1, then loading protocol is not overridden for drone1, then loading protocol is locked for drone1.",
      "If it is not the case that if it is not the case that if loading protocol is enforced for drone1 then if package1 is loaded on drone1, package1 is not secured on drone1, then loading protocol is not overridden for drone1, then loading protocol is not locked for drone1.",
      "Under the condition that it is not the case that if it is not the case that if it is not the case that if loading protocol is enforced for drone1 then if package1 is loaded on drone1, package1 is not secured on drone1, then loading protocol is not overridden for drone1, then loading protocol is locked for drone1, then delivery of package1 is completed.",
      "Whenever weather system monitor1 is not functional, weather system monitor1 has malfunctioned.",
      "Provided that weather system monitor1 is not functional, weather system monitor1 has not malfunctioned.",
      "If command center1 is not functional, then delivery of package1 is delayed.",
      "Route1 is clear.",
      "Weather in area1 is clear.",
      "Weather in area1 is monitored.",
      "Weather system monitor1 is functional.",
      "Loading protocol is enforced for drone1.",
      "Command center1 is functional.",
      "Damage protocol is enabled for drone1.",
      "Dispatch system1 is operational.",
      "Dispatch system1 is monitored.",
      "Delivery of package1 is successful.",
      "There is no loading error for package1 on drone1.",
      "Route1 is not blocked.",
      "Delivery of package1 is not completed.",
      "Delivery of package1 has not failed.",
      "Delivery of package1 is not delayed.",
      "Package1 is not loaded on drone1."
    ],
    "node_mappings": {
      "(A1 → G)": {
        "formal": "(A1 → G)",
        "prover9": "(A1 -> G)",
        "prover9_expression": "(vehicle_available(drone1, station1) -> delivery_successful(package1))",
        "natural": "Provided that drone1 is available at station1, delivery of package1 is successful."
      },
      "(A1 ∨ A2)": {
        "formal": "(A1 ∨ A2)",
        "prover9": "(A1 | A2)",
        "prover9_expression": "(vehicle_available(drone1, station1) | vehicle_available(robocar1, station1))",
        "natural": "Either drone1 is available at station1 or robocar1 is available at station1."
      },
      "(A11 → A12)": {
        "formal": "(A11 → A12)",
        "prover9": "(A11 -> A12)",
        "prover9_expression": "(loading_error(package1, drone1) -> loading_complete(package1, drone1))",
        "natural": "Whenever there is a loading error for package1 on drone1, loading of package1 on drone1 is complete."
      },
      "(A11 → ¬A12)": {
        "formal": "(A11 → ¬A12)",
        "prover9": "(A11 -> -A12)",
        "prover9_expression": "(loading_error(package1, drone1) -> -loading_complete(package1, drone1))",
        "natural": "If there is a loading error for package1 on drone1, then it is not the case that loading of package1 on drone1 is complete."
      },
      "(A13 → ¬A9)": {
        "formal": "(A13 → ¬A9)",
        "prover9": "(A13 -> -A9)",
        "prover9_expression": "(route_clear(route1) -> -package_loaded(package1, drone1))",
        "natural": "Under the condition that route1 is clear, package1 is not loaded on drone1."
      },
      "(A14 ∨ A13)": {
        "formal": "(A14 ∨ A13)",
        "prover9": "(A14 | A13)",
        "prover9_expression": "(route_blocked(route1) | route_clear(route1))",
        "natural": "Route1 is blocked or route1 is clear."
      },
      "(A15 → ¬A14)": {
        "formal": "(A15 → ¬A14)",
        "prover9": "(A15 -> -A14)",
        "prover9_expression": "(alternative_route_available(route2) -> -route_blocked(route1))",
        "natural": "Provided that alternative route2 is available, route1 is not blocked."
      },
      "(A15 ∨ A16)": {
        "formal": "(A15 ∨ A16)",
        "prover9": "(A15 | A16)",
        "prover9_expression": "(alternative_route_available(route2) | alternative_route_available(route3))",
        "natural": "Alternative route2 is available or alternative route3 is available."
      },
      "(A16 → ¬A14)": {
        "formal": "(A16 → ¬A14)",
        "prover9": "(A16 -> -A14)",
        "prover9_expression": "(alternative_route_available(route3) -> -route_blocked(route1))",
        "natural": "Whenever alternative route3 is available, route1 is not blocked."
      },
      "(A17 → (A16 → ¬A14))": {
        "formal": "(A17 → (A16 → ¬A14))",
        "prover9": "(A17 -> (A16 -> -A14))",
        "prover9_expression": "(weather_clear(area1) -> (alternative_route_available(route3) -> -route_blocked(route1)))",
        "natural": "If weather in area1 is clear, then whenever alternative route3 is available, route1 is not blocked."
      },
      "(A18 → A17)": {
        "formal": "(A18 → A17)",
        "prover9": "(A18 -> A17)",
        "prover9_expression": "(weather_monitored(area1) -> weather_clear(area1))",
        "natural": "Under the condition that weather in area1 is monitored, weather in area1 is clear."
      },
      "(A19 → A18)": {
        "formal": "(A19 → A18)",
        "prover9": "(A19 -> A18)",
        "prover9_expression": "(weather_system_functional(monitor1) -> weather_monitored(area1))",
        "natural": "Provided that weather system monitor1 is functional, weather in area1 is monitored."
      },
      "(A2 → G)": {
        "formal": "(A2 → G)",
        "prover9": "(A2 -> G)",
        "prover9_expression": "(vehicle_available(robocar1, station1) -> delivery_successful(package1))",
        "natural": "If robocar1 is available at station1, then delivery of package1 is successful."
      },
      "(A21 → (A9 → ¬A10))": {
        "formal": "(A21 → (A9 → ¬A10))",
        "prover9": "(A21 -> (A9 -> -A10))",
        "prover9_expression": "(loading_protocol_enforced(drone1) -> (package_loaded(package1, drone1) -> -package_secured(package1, drone1)))",
        "natural": "Whenever loading protocol is enforced for drone1, then if package1 is loaded on drone1, package1 is not secured on drone1."
      },
      "(A25 ∨ ¬A24)": {
        "formal": "(A25 ∨ ¬A24)",
        "prover9": "(A25 | -A24)",
        "prover9_expression": "(delivery_failed(package1) | -delivery_completed(package1))",
        "natural": "Either delivery of package1 has failed or delivery of package1 is not completed."
      },
      "(A26 → ¬A25)": {
        "formal": "(A26 → ¬A25)",
        "prover9": "(A26 -> -A25)",
        "prover9_expression": "(vehicle_recovered(drone1) -> -delivery_failed(package1))",
        "natural": "Provided that drone1 has been recovered, delivery of package1 has not failed."
      },
      "(A26 ∨ A27)": {
        "formal": "(A26 ∨ A27)",
        "prover9": "(A26 | A27)",
        "prover9_expression": "(vehicle_recovered(drone1) | vehicle_lost(drone1))",
        "natural": "Drone1 has been recovered or drone1 is lost."
      },
      "(A27 → ¬A25)": {
        "formal": "(A27 → ¬A25)",
        "prover9": "(A27 -> -A25)",
        "prover9_expression": "(vehicle_lost(drone1) -> -delivery_failed(package1))",
        "natural": "Under the condition that drone1 is lost, delivery of package1 has not failed."
      },
      "(A29 → ¬A28)": {
        "formal": "(A29 → ¬A28)",
        "prover9": "(A29 -> -A28)",
        "prover9_expression": "(recovery_canceled(drone1) -> -recovery_initiated(drone1))",
        "natural": "If recovery of drone1 has been canceled, then recovery of drone1 has not been initiated."
      },
      "(A3 → (A1 → G))": {
        "formal": "(A3 → (A1 → G))",
        "prover9": "(A3 -> (A1 -> G))",
        "prover9_expression": "(command_center_functional(center1) -> (vehicle_available(drone1, station1) -> delivery_successful(package1)))",
        "natural": "Whenever command center1 is functional, then if drone1 is available at station1, delivery of package1 is successful."
      },
      "(A30 → ¬A10)": {
        "formal": "(A30 → ¬A10)",
        "prover9": "(A30 -> -A10)",
        "prover9_expression": "(package_damaged(package1) -> -package_secured(package1, drone1))",
        "natural": "Provided that package1 is damaged, package1 is not secured on drone1."
      },
      "(A31 → (A30 → ¬A10))": {
        "formal": "(A31 → (A30 → ¬A10))",
        "prover9": "(A31 -> (A30 -> -A10))",
        "prover9_expression": "(damage_protocol_enabled(drone1) -> (package_damaged(package1) -> -package_secured(package1, drone1)))",
        "natural": "If damage protocol is enabled for drone1, then if package1 is damaged, package1 is not secured on drone1."
      },
      "(A32 → (A31 → (A30 → ¬A10)))": {
        "formal": "(A32 → (A31 → (A30 → ¬A10)))",
        "prover9": "(A32 -> (A31 -> (A30 -> -A10)))",
        "prover9_expression": "(damage_detected(package1) -> (damage_protocol_enabled(drone1) -> (package_damaged(package1) -> -package_secured(package1, drone1))))",
        "natural": "Under the condition that damage to package1 has been detected, then if damage protocol is enabled for drone1, then if package1 is damaged, package1 is not secured on drone1."
      },
      "(A32 ∨ A33)": {
        "formal": "(A32 ∨ A33)",
        "prover9": "(A32 | A33)",
        "prover9_expression": "(damage_detected(package1) | damage_undetected(package1))",
        "natural": "Damage to package1 has been detected or damage to package1 is undetected."
      },
      "(A33 → (A31 → (A30 → ¬A10)))": {
        "formal": "(A33 → (A31 → (A30 → ¬A10)))",
        "prover9": "(A33 -> (A31 -> (A30 -> -A10)))",
        "prover9_expression": "(damage_undetected(package1) -> (damage_protocol_enabled(drone1) -> (package_damaged(package1) -> -package_secured(package1, drone1))))",
        "natural": "Provided that damage to package1 is undetected, then if damage protocol is enabled for drone1, then if package1 is damaged, package1 is not secured on drone1."
      },
      "(A34 → (A32 ∨ A33))": {
        "formal": "(A34 → (A32 ∨ A33))",
        "prover9": "(A34 -> (A32 | A33))",
        "prover9_expression": "(inspection_scheduled(package1) -> (damage_detected(package1) | damage_undetected(package1)))",
        "natural": "If inspection of package1 is scheduled, then either damage to package1 has been detected or damage to package1 is undetected."
      },
      "(A34 ∨ A35)": {
        "formal": "(A34 ∨ A35)",
        "prover9": "(A34 | A35)",
        "prover9_expression": "(inspection_scheduled(package1) | inspection_bypassed(package1))",
        "natural": "Inspection of package1 is scheduled or inspection of package1 is bypassed."
      },
      "(A35 → (A32 ∨ A33))": {
        "formal": "(A35 → (A32 ∨ A33))",
        "prover9": "(A35 -> (A32 | A33))",
        "prover9_expression": "(inspection_bypassed(package1) -> (damage_detected(package1) | damage_undetected(package1)))",
        "natural": "Provided that inspection of package1 is bypassed, then either damage to package1 has been detected or damage to package1 is undetected."
      },
      "(A5 → ¬A4)": {
        "formal": "(A5 → ¬A4)",
        "prover9": "(A5 -> -A4)",
        "prover9_expression": "(device_online(charger1) -> -delivery_delayed(package1))",
        "natural": "Whenever charger1 is online, delivery of package1 is not delayed."
      },
      "(A5 ∨ A6)": {
        "formal": "(A5 ∨ A6)",
        "prover9": "(A5 | A6)",
        "prover9_expression": "(device_online(charger1) | device_online(backup_charger1))",
        "natural": "Either charger1 is online or backup charger1 is online."
      },
      "(A6 → ¬A4)": {
        "formal": "(A6 → ¬A4)",
        "prover9": "(A6 -> -A4)",
        "prover9_expression": "(device_online(backup_charger1) -> -delivery_delayed(package1))",
        "natural": "Under the condition that backup charger1 is online, delivery of package1 is not delayed."
      },
      "(A7 → (A5 ∨ A6))": {
        "formal": "(A7 → (A5 ∨ A6))",
        "prover9": "(A7 -> (A5 | A6))",
        "prover9_expression": "(platform_operational(dispatch_system1) -> (device_online(charger1) | device_online(backup_charger1)))",
        "natural": "If dispatch system1 is operational, then either charger1 is online or backup charger1 is online."
      },
      "(A8 → (A7 → (A5 ∨ A6)))": {
        "formal": "(A8 → (A7 → (A5 ∨ A6)))",
        "prover9": "(A8 -> (A7 -> (A5 | A6)))",
        "prover9_expression": "(platform_monitored(dispatch_system1) -> (platform_operational(dispatch_system1) -> (device_online(charger1) | device_online(backup_charger1))))",
        "natural": "Provided that dispatch system1 is monitored, then if dispatch system1 is operational, then either charger1 is online or backup charger1 is online."
      },
      "(A9 → A10)": {
        "formal": "(A9 → A10)",
        "prover9": "(A9 -> A10)",
        "prover9_expression": "(package_loaded(package1, drone1) -> package_secured(package1, drone1))",
        "natural": "Whenever package1 is loaded on drone1, package1 is secured on drone1."
      },
      "(A9 → A30)": {
        "formal": "(A9 → A30)",
        "prover9": "(A9 -> A30)",
        "prover9_expression": "(package_loaded(package1, drone1) -> package_damaged(package1))",
        "natural": "If package1 is loaded on drone1, then package1 is damaged."
      },
      "(A9 → ¬A10)": {
        "formal": "(A9 → ¬A10)",
        "prover9": "(A9 -> -A10)",
        "prover9_expression": "(package_loaded(package1, drone1) -> -package_secured(package1, drone1))",
        "natural": "Provided that package1 is loaded on drone1, package1 is not secured on drone1."
      },
      "(A9 ∨ G)": {
        "formal": "(A9 ∨ G)",
        "prover9": "(A9 | G)",
        "prover9_expression": "(package_loaded(package1, drone1) | delivery_successful(package1))",
        "natural": "Package1 is loaded on drone1 or delivery of package1 is successful."
      },
      "(¬(A21 → (A9 → ¬A10)) → A22)": {
        "formal": "(¬(A21 → (A9 → ¬A10)) → A22)",
        "prover9": "(-(A21 -> (A9 -> -A10)) -> A22)",
        "prover9_expression": "(-(loading_protocol_enforced(drone1) -> (package_loaded(package1, drone1) -> -package_secured(package1, drone1))) -> loading_protocol_override(drone1))",
        "natural": "Whenever it is not the case that if loading protocol is enforced for drone1 then if package1 is loaded on drone1, package1 is not secured on drone1, then loading protocol is overridden for drone1."
      },
      "(¬(A21 → (A9 → ¬A10)) → ¬A22)": {
        "formal": "(¬(A21 → (A9 → ¬A10)) → ¬A22)",
        "prover9": "(-(A21 -> (A9 -> -A10)) -> -A22)",
        "prover9_expression": "(-(loading_protocol_enforced(drone1) -> (package_loaded(package1, drone1) -> -package_secured(package1, drone1))) -> -loading_protocol_override(drone1))",
        "natural": "If it is not the case that if loading protocol is enforced for drone1 then if package1 is loaded on drone1, package1 is not secured on drone1, then loading protocol is not overridden for drone1."
      },
      "(¬(A26 ∨ A27) → A28)": {
        "formal": "(¬(A26 ∨ A27) → A28)",
        "prover9": "(-(A26 | A27) -> A28)",
        "prover9_expression": "(-(vehicle_recovered(drone1) | vehicle_lost(drone1)) -> recovery_initiated(drone1))",
        "natural": "Provided that it is not the case that drone1 has been recovered or drone1 is lost, then recovery of drone1 has been initiated."
      },
      "(¬(A26 ∨ A27) → A29)": {
        "formal": "(¬(A26 ∨ A27) → A29)",
        "prover9": "(-(A26 | A27) -> A29)",
        "prover9_expression": "(-(vehicle_recovered(drone1) | vehicle_lost(drone1)) -> recovery_canceled(drone1))",
        "natural": "If it is not the case that drone1 has been recovered or drone1 is lost, then recovery of drone1 has been canceled."
      },
      "(¬(A26 ∨ A27) → ¬A28)": {
        "formal": "(¬(A26 ∨ A27) → ¬A28)",
        "prover9": "(-(A26 | A27) -> -A28)",
        "prover9_expression": "(-(vehicle_recovered(drone1) | vehicle_lost(drone1)) -> -recovery_initiated(drone1))",
        "natural": "Under the condition that it is not the case that drone1 has been recovered or drone1 is lost, then recovery of drone1 has not been initiated."
      },
      "(¬(A9 → ¬A10) → A11)": {
        "formal": "(¬(A9 → ¬A10) → A11)",
        "prover9": "(-(A9 -> -A10) -> A11)",
        "prover9_expression": "(-(package_loaded(package1, drone1) -> -package_secured(package1, drone1)) -> loading_error(package1, drone1))",
        "natural": "Whenever it is not the case that if package1 is loaded on drone1, then package1 is not secured on drone1, then there is a loading error for package1 on drone1."
      },
      "(¬(¬(A21 → (A9 → ¬A10)) → ¬A22) → A23)": {
        "formal": "(¬(¬(A21 → (A9 → ¬A10)) → ¬A22) → A23)",
        "prover9": "(-(-(A21 -> (A9 -> -A10)) -> -A22) -> A23)",
        "prover9_expression": "(-(-(loading_protocol_enforced(drone1) -> (package_loaded(package1, drone1) -> -package_secured(package1, drone1))) -> -loading_protocol_override(drone1)) -> loading_protocol_locked(drone1))",
        "natural": "Provided that it is not the case that if it is not the case that if loading protocol is enforced for drone1 then if package1 is loaded on drone1, package1 is not secured on drone1, then loading protocol is not overridden for drone1, then loading protocol is locked for drone1."
      },
      "(¬(¬(A21 → (A9 → ¬A10)) → ¬A22) → ¬A23)": {
        "formal": "(¬(¬(A21 → (A9 → ¬A10)) → ¬A22) → ¬A23)",
        "prover9": "(-(-(A21 -> (A9 -> -A10)) -> -A22) -> -A23)",
        "prover9_expression": "(-(-(loading_protocol_enforced(drone1) -> (package_loaded(package1, drone1) -> -package_secured(package1, drone1))) -> -loading_protocol_override(drone1)) -> -loading_protocol_locked(drone1))",
        "natural": "If it is not the case that if it is not the case that if loading protocol is enforced for drone1 then if package1 is loaded on drone1, package1 is not secured on drone1, then loading protocol is not overridden for drone1, then loading protocol is not locked for drone1."
      },
      "(¬(¬(¬(A21 → (A9 → ¬A10)) → ¬A22) → A23) → A24)": {
        "formal": "(¬(¬(¬(A21 → (A9 → ¬A10)) → ¬A22) → A23) → A24)",
        "prover9": "(-(-(-(A21 -> (A9 -> -A10)) -> -A22) -> A23) -> A24)",
        "prover9_expression": "(-(-(-(loading_protocol_enforced(drone1) -> (package_loaded(package1, drone1) -> -package_secured(package1, drone1))) -> -loading_protocol_override(drone1)) -> loading_protocol_locked(drone1)) -> delivery_completed(package1))",
        "natural": "Under the condition that it is not the case that if it is not the case that if it is not the case that if loading protocol is enforced for drone1 then if package1 is loaded on drone1, package1 is not secured on drone1, then loading protocol is not overridden for drone1, then loading protocol is locked for drone1, then delivery of package1 is completed."
      },
      "(¬A19 → A20)": {
        "formal": "(¬A19 → A20)",
        "prover9": "(-A19 -> A20)",
        "prover9_expression": "(-weather_system_functional(monitor1) -> weather_system_malfunction(monitor1))",
        "natural": "Whenever weather system monitor1 is not functional, weather system monitor1 has malfunctioned."
      },
      "(¬A19 → ¬A20)": {
        "formal": "(¬A19 → ¬A20)",
        "prover9": "(-A19 -> -A20)",
        "prover9_expression": "(-weather_system_functional(monitor1) -> -weather_system_malfunction(monitor1))",
        "natural": "Provided that weather system monitor1 is not functional, weather system monitor1 has not malfunctioned."
      },
      "(¬A3 → A4)": {
        "formal": "(¬A3 → A4)",
        "prover9": "(-A3 -> A4)",
        "prover9_expression": "(-command_center_functional(center1) -> delivery_delayed(package1))",
        "natural": "If command center1 is not functional, then delivery of package1 is delayed."
      },
      "A13": {
        "formal": "A13",
        "prover9": "A13",
        "prover9_expression": "route_clear(route1)",
        "natural": "Route1 is clear."
      },
      "A17": {
        "formal": "A17",
        "prover9": "A17",
        "prover9_expression": "weather_clear(area1)",
        "natural": "Weather in area1 is clear."
      },
      "A18": {
        "formal": "A18",
        "prover9": "A18",
        "prover9_expression": "weather_monitored(area1)",
        "natural": "Weather in area1 is monitored."
      },
      "A19": {
        "formal": "A19",
        "prover9": "A19",
        "prover9_expression": "weather_system_functional(monitor1)",
        "natural": "Weather system monitor1 is functional."
      },
      "A21": {
        "formal": "A21",
        "prover9": "A21",
        "prover9_expression": "loading_protocol_enforced(drone1)",
        "natural": "Loading protocol is enforced for drone1."
      },
      "A3": {
        "formal": "A3",
        "prover9": "A3",
        "prover9_expression": "command_center_functional(center1)",
        "natural": "Command center1 is functional."
      },
      "A31": {
        "formal": "A31",
        "prover9": "A31",
        "prover9_expression": "damage_protocol_enabled(drone1)",
        "natural": "Damage protocol is enabled for drone1."
      },
      "A7": {
        "formal": "A7",
        "prover9": "A7",
        "prover9_expression": "platform_operational(dispatch_system1)",
        "natural": "Dispatch system1 is operational."
      },
      "A8": {
        "formal": "A8",
        "prover9": "A8",
        "prover9_expression": "platform_monitored(dispatch_system1)",
        "natural": "Dispatch system1 is monitored."
      },
      "G": {
        "formal": "G",
        "prover9": "G",
        "prover9_expression": "delivery_successful(package1)",
        "natural": "Delivery of package1 is successful."
      },
      "¬A11": {
        "formal": "¬A11",
        "prover9": "-A11",
        "prover9_expression": "-loading_error(package1, drone1)",
        "natural": "There is no loading error for package1 on drone1."
      },
      "¬A14": {
        "formal": "¬A14",
        "prover9": "-A14",
        "prover9_expression": "-route_blocked(route1)",
        "natural": "Route1 is not blocked."
      },
      "¬A24": {
        "formal": "¬A24",
        "prover9": "-A24",
        "prover9_expression": "-delivery_completed(package1)",
        "natural": "Delivery of package1 is not completed."
      },
      "¬A25": {
        "formal": "¬A25",
        "prover9": "-A25",
        "prover9_expression": "-delivery_failed(package1)",
        "natural": "Delivery of package1 has not failed."
      },
      "¬A4": {
        "formal": "¬A4",
        "prover9": "-A4",
        "prover9_expression": "-delivery_delayed(package1)",
        "natural": "Delivery of package1 is not delayed."
      },
      "¬A9": {
        "formal": "¬A9",
        "prover9": "-A9",
        "prover9_expression": "-package_loaded(package1, drone1)",
        "natural": "Package1 is not loaded on drone1."
      }
    }
  }
}